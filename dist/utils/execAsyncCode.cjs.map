{"version":3,"sources":["../../src/utils/execAsyncCode.ts"],"sourcesContent":["const AsyncFunction = Object.getPrototypeOf(async function(){}).constructor;\n\nasync function runAsyncCode(codeString : string, context = {}) {\n    let userFunc : any\n    if (typeof codeString !== 'string') \n        throw new TypeError('The first argument must be a string of code');\n    if(isCallbackString(codeString)){\n        try { // if we got a callback string, we need to return it as is\n            userFunc = eval(`(${codeString})`);\n            let result = await userFunc(context);\n            return result;\n        } catch (error: any) {\n            throw error;\n        }\n    }\n    try{ // if we have normal code, we make the whole context available\n        userFunc = new AsyncFunction(...Object.keys(context), codeString);\n        const result = await userFunc(...Object.values(context));\n        return result ;\n    } catch (error: any) {\n        throw error;\n    }\n}\n\nfunction isCallbackString(code: string) {\n  try {\n    const fn = eval(`(${code})`);\n    return typeof fn === 'function';\n  } catch (e) {\n    return false;\n  }\n}\n\nexport default runAsyncCode;\n\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAAM,gBAAgB,OAAO,eAAe,iBAAgB;AAAC,CAAC,EAAE;AAEhE,eAAe,aAAa,YAAqB,UAAU,CAAC,GAAG;AAC3D,MAAI;AACJ,MAAI,OAAO,eAAe;AACtB,UAAM,IAAI,UAAU,6CAA6C;AACrE,MAAG,iBAAiB,UAAU,GAAE;AAC5B,QAAI;AACA,iBAAW,KAAK,IAAI,UAAU,GAAG;AACjC,UAAI,SAAS,MAAM,SAAS,OAAO;AACnC,aAAO;AAAA,IACX,SAAS,OAAY;AACjB,YAAM;AAAA,IACV;AAAA,EACJ;AACA,MAAG;AACC,eAAW,IAAI,cAAc,GAAG,OAAO,KAAK,OAAO,GAAG,UAAU;AAChE,UAAMA,UAAS,MAAM,SAAS,GAAG,OAAO,OAAO,OAAO,CAAC;AACvD,WAAOA;AAAA,EACX,SAAS,OAAY;AACjB,UAAM;AAAA,EACV;AACJ;AAEA,SAAS,iBAAiB,MAAc;AACtC,MAAI;AACF,UAAM,KAAK,KAAK,IAAI,IAAI,GAAG;AAC3B,WAAO,OAAO,OAAO;AAAA,EACvB,SAAS,GAAG;AACV,WAAO;AAAA,EACT;AACF;AAEA,IAAO,wBAAQ;","names":["result"]}