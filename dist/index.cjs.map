{"version":3,"sources":["../src/index.ts","../src/network/Connection.ts","../src/utils/Queue.ts","../src/utils/Pool.ts","../src/utils/log.ts","../src/utils/uuids.ts","../src/utils/await_interval.ts","../src/utils/toListeners.ts","../src/utils/ipAndPort.ts","../src/utils/isServerActive.ts","../src/utils/execAsyncCode.ts","../src/network/Server.ts","../src/network/Network.ts","../src/network/index.ts","../src/cluster/ProcessCluster.ts","../src/cluster/index.ts","../src/app/peerDiscovery/PeerDiscoveryServer.ts","../src/app/peerDiscovery/PeerDiscoveryClient.ts","../src/app/peerDiscovery/index.ts","../src/app/makeProxyObject.ts","../src/nodes/Node.ts","../src/nodes/NodeManager.ts","../src/nodes/index.ts","../src/service/RequestQueue.ts","../src/service/ProcessBalancer.ts","../src/service/ServiceClient.ts","../src/service/Stash.ts","../src/service/Service.ts","../src/service/index.ts","../src/app/typeGuards.ts","../src/app/entry.ts","../src/app/extractFunctions.ts","../src/app/index.ts"],"sourcesContent":["/* this class the slavery entry point */\nimport entry, { PeerDiscoverer }  from './app/index.js'\nimport Node from './nodes/index.js'\nimport  Service from './service/index.js'\n\nexport default entry\n\nexport { Service, Node, PeerDiscoverer }\n\n\n","import { io } from \"socket.io-client\";\nimport { Socket } from 'socket.io';\nimport log from '../utils/log.js';\nimport type Listener from './types/Listener.js';\n\nclass Connection {\n    /*\n     * this class is manager for the socket instance\n     * it takes either a socket or a host and port to create the socket\n     * if it takes the host and port it will consider that connection is a server\n     * if it takes a socket it will consider that connection is a client\n     *\n     * it manages conenction, the listeners and the available emitters */\n    private socket: Socket | any;\n    private request_id: number = 0;\n    // this node information\n    public name?: string;\n    public id?: string;\n    public listeners: Listener[] = [];\n    public type: 'client' | 'server';\n    public host?: string;\n    public port?: number;\n    // is connected or not\n    public isConnected: boolean;\n    // ot target of the socket\n    public socketId: string;\n    public targetType: 'client' | 'server';\n    public targetName?: string;\n    public targetId?: string;\n    public targetListeners: Listener[] = [];\n    public targetHost?: string;\n    public targetPort?: number;\n    // callbacks\n    private onConnectCallback: Function;\n    public onDisconnectCallback: Function;\n    public onSetListenersCallback: Function;\n\n    /*\n     * @param Node: Node\n     * @param socket: Socket\n     * @param host: string\n     * @param port: number\n     * @param id: string\n     * @param name: string\n     * */\n\n    constructor({ socket, host, port, id, name, listeners, timeout,\n                onConnect, onDisconnect, onSetListeners } : {\n        id?: string, socket?: Socket, host?: string,\n        port?: number, name?: string, listeners?: Listener[],\n        timeout?: number, onConnect?: Function, onDisconnect?: Function,\n        onSetListeners?: Function\n    }) {\n        // callbacks\n        this.onConnectCallback = onConnect || (() => {});\n        this.onDisconnectCallback = onDisconnect || (() => {});\n        this.onSetListenersCallback = onSetListeners || (() => {});\n        // set listeners\n        if(listeners) this.listeners = listeners;\n        // if get a socket to connect to the server\n        if (socket && name) {\n            this.type = 'server';\n            this.name = name;\n            this.targetType = 'client';\n            // the socket\n            this.socket = socket;\n            // get the id of client\n            this.targetId = socket.handshake.auth.id;\n            //log('[Connection][server] targetId: ', this.targetId)\n            // since we are already getting the socket\n            this.isConnected = true;\n            // if get a host and port to connect to the server\n        } else if (host && port && id) {\n            this.type = 'client';\n            this.targetType = 'server';\n            // use the id\n            this.id = id;\n            this.socket = io(`ws://${host}:${port}`, {\n                auth: { id },\n                timeout: timeout || 1000 * 60 // 1 minute\n            });\n            // since we are not connected yet\n            this.isConnected = false;\n        } else\n            throw new Error('Connection must have either a socket and a name or a host and port');\n        // set the socket id\n        this.socketId = this.socket.id;\n        // initialize the listeners\n        this.initilaizeListeners()\n    }\n\n    private initilaizeListeners(): void {\n        /* this function inizializes the default listeners for the socket */\n        // set the object listeners \n        this.listeners.forEach( l => {\n            this.socket.removeAllListeners(l.event);\n            this.socket.on(l.event, this.respond(l.event, async (parameters:any) => {\n                //log(`[${this.id}] [Connection][initilaizeListeners] got event: ${l.event} from ${this.targetName}: `, parameters)\n                return await l.callback(parameters);\n            }));\n        });\n        // if target is asking for connections\n        this.socket.on(\"_listeners\", this.respond(\"_listeners\", () => this.getListeners()));\n        // if the target is sending a their listeners\n        this.socket.on(\"_set_listeners\", this.respond(\"_set_listeners\", (listeners: string[]) => {\n            //log(`[${this.id}] [Connection][Node] got liteners from ${this.targetName}: `, listeners)\n            this.targetListeners =\n                listeners.map(event => ({ event, callback: () => {} }));\n            this.onSetListenersCallback(this.targetListeners);\n            return 'ok';\n        }));\n        // if target is asking for name\n        this.socket.on(\"_name\", this.respond(\"_name\", () => this.name));\n        // if target is asking for id\n        this.socket.on(\"_id\", () => this.id);\n        // on connected\n        this.socket.on(\"connect\", async () => {\n            //log(`[connection][${this.socket.id}] is connected, querying target name and listeners:`)\n            // ask for listeners\n            this.targetName = await this.queryTargetName();\n            this.targetListeners = await this.queryTargetListeners();\n            //log(`[connection][${this.socket.id}] target name: ${this.targetName}, target listeners: ${this.targetListeners}`)\n            this.isConnected = true;\n            this.onConnectCallback(this);\n        });\n        // if it disconnects\n        this.socket.on(\"reconnect\", async (attempt: number) => {\n            //log(`[connection][${this.socket.id}] is reconnected, attempt: ${attempt}`)\n            this.targetName = await this.queryTargetName();\n            this.targetListeners = await this.queryTargetListeners();\n            this.isConnected = true;\n            this.onConnectCallback(this);\n        });\n        // if it disconnects\n        this.socket.on(\"diconnect\", () => {\n            //log(`[connection][${this.socket.id}] is disconnected`)\n            this.isConnected = false;\n            this.onDisconnectCallback(this);\n        });\n    }\n\n    public async connected(): Promise<boolean> {\n        return new Promise((resolve, reject) => {\n            let interval: NodeJS.Timeout;\n            let timeout: NodeJS.Timeout\n            // set interval to check for connection\n            interval = setInterval(() => {\n                if(this.isConnected) {\n                    clearInterval(interval);\n                    clearTimeout(timeout);\n                    resolve(true);\n                }\n            }, 100); // 100 ms\n            // set timeout to reject if no connection\n            timeout = setTimeout(() => {\n                clearInterval(interval);\n                reject(false);\n            }, 1000 * 60 ); // 1 minute\n        })\n    }\n\n\n    public getType(){\n        return this.type;\n    }\n\n    public on(event: string, callback: Function): void {\n        this.socket.on(event, callback);\n    }\n\n    public emit(event: string, data: any): void {\n        this.socket.emit(event, data);\n    }\n\n    public getName(): string | undefined {\n        return this.name;\n    }\n\n    // this is the id of the conenction?\n    public getId(): string | undefined {\n        return this.id;\n    }\n\n    public getTargetName(): string | undefined {\n        return this.targetName;\n    }\n\n    // this is the id of the target client\n    public getTargetId(): string | undefined {\n        return this.targetId;\n    }\n\n    public async setListeners(listeners: Listener[]): Promise<void> {\n        // set the listeners on the socket\n        listeners.forEach( l => {\n            this.listeners.push(l);\n            // remove the listener if it exists\n            this.socket.removeAllListeners(l.event);\n            // add new listener\n            this.socket.on(l.event, this.respond(l.event, async (parameters:any) => {\n                // run the callback defined in the listner\n                return await l.callback(parameters);\n            }));    \n        });\n        // update the listeners on the target\n        if(this.type === 'server'){\n            //let response = \n            await this.query('_set_listeners', listeners.map(listener => listener.event));\n            //if(response === 'ok') log('[Connection]<setListeners> listeners set successfully')\n        }\n    }\n\n    public addListeners(listeners: Listener[]): void {\n        // make sure we are not adding the same listener\n        const eventMap = new Map(this.listeners.map(l => [l.event, l]));\n        // add the listeners\n        listeners.forEach( l => eventMap.set(l.event, l) );\n        // set the listeners in the connection\n        this.listeners = Array.from(eventMap.values());\n        // set the listeners on the socket\n        this.setListeners(this.listeners);\n    }\n\n    public getTargetListeners(): Listener[] {\n        return this.targetListeners;\n    }\n\n    public onSetListeners(callback: Function): void {\n        this.onSetListenersCallback = callback;\n    }\n\n    public onConnect(callback: Function): void {\n        this.onConnectCallback = callback;\n    }\n\n    public onDisconnect(callback: Function): void {\n        this.onDisconnectCallback = callback;\n    }\n\n    private queryTargetListeners(): Promise<Listener[]> {\n        // query the target listeners\n        return this.query('_listeners');\n    }\n\n    private queryTargetName(): Promise<string> {\n        // query the target name\n        return this.query('_name');\n    }\n\n    // this function need to be awaited\n    public query(event: string, data?: any): Promise<any> {\n        /* this function makes the query to the socket and waits for the response */\n        return new Promise((resolve, reject) => {\n            // set a time out\n            let timeout = setTimeout( () => { reject('timeout') }, 1000 * 60); // 1 minute\n            // get request id\n            let request_id = ++this.request_id;\n            if (this.request_id >= Number.MAX_SAFE_INTEGER - 1) this.request_id = 0;\n            // send the query\n            this.socket.emit(event, {data, request_id: request_id});\n            this.socket.on(event + `_${request_id}_response`, (response: any) => {\n                //log('[Connection][Query] got response from ', this.targetType, 'event: ', event, 'response: ', response)\n                // clear the timeout\n                clearTimeout(timeout);\n                // clear the listener\n                this.socket.removeAllListeners(event + `_${request_id}_response`);\n                // resolve the response\n                resolve(response);\n            });\n        });\n    }\n\n    public send = this.query;\n\n    private respond(event: string, callback: Function) {\n        /* this is a wrapper function to respond to a query */\n        return async (parameters: any) => {\n            let data = parameters.data;\n            let request_id = parameters.request_id;\n            let response = await callback(data);\n            this.socket.emit(event + `_${request_id}_response`, response);\n        }\n    }\n\n    public getListeners(): any[] {\n        if(this.type === 'server')\n            return this.listeners;\n        else if(this.type === 'client')\n            return this.socket._callbacks;\n        else\n            throw new Error('Connection type not recognized');\n    }\n\n    public close(): void {\n        this.socket.disconnect();\n    }\n\n}\n\nexport default Connection;\n","class Queue<T> {\n    private items: T[] = [];\n\n    constructor( items: T[] = [] ) {\n        if(items.length > 0)\n            this.items = items\n        else\n            this.items = []\n    }\n\n    enqueue(item: T) {\n        // push item to the end of the queue\n        this.items.push(item)\n        return true;\n    }\n\n    dequeue(): T | false {\n        // remove item from the beginning of the queue\n        if(this.items.length > 0) {\n            const item = this.items.shift()\n            if(item === undefined) return false;\n            return item;\n        }\n        return false;\n    }\n\n    next(): T | false {\n        // dequeue and enqueue\n        if(this.items.length > 0) {\n            const item = this.items.shift()\n            if(item) {\n                this.items.push(item)\n                return item\n            }\n        }\n        return false;\n    }\n\n    // remove value while maintaining order\n    removeAt( index: number) : T | false {\n        if (index > -1 && index < this.items.length) {\n            return this.items.splice(index, 1)[0];\n        }else {\n            return false;\n        }\n    }\n\n    indexOf(item: T) : number {\n        return this.items.indexOf(item);\n    }\n\n    remove(item: T) : T | false {\n        const index = this.items.indexOf(item);\n        if (index > -1) {\n            return this.items.splice(index, 1)[0];\n        }else {\n            return false;\n        }\n    }\n\n    peek(): T | false {\n        return this.items[0]\n    }\n\n    printQueue() : T[] {\n        return this.items;\n    }\n\n    // return array of items in the order they were added\n    toArray() : T[] {\n        return this.items;\n    }\n\n    // return object of items in the order they were added\n    toObject() : object {\n        let obj: { [key: string]: T } = {};\n        this.items.forEach( (item, index) => {\n            obj[index] = item;\n        });\n        return obj;\n    }\n\n    // get the size of the queue\n    size() : number {\n        return this.items.length;\n    }\n\n    // lenght of the queue\n    length() : number {\n        return this.items.length;\n    }\n\n    // check if queue is empty\n    isEmpty() : boolean {\n        return this.items.length === 0;\n    }\n\n    // clear the queue\n    clear = () => this.items = [];\n\n    // synonyms\n    pop =  this.dequeue;\n    push = this.enqueue;\n    shift = this.dequeue;\n    unshift = this.enqueue;\n    front = this.peek;\n    end = this.next;\n}\n\nexport default Queue;\n","import Queue from './Queue.js'\n\nclass Pool<T> {\n    /* *\n     * this class handle the socket connectd\n     * queue of sockets and manages connection with the workers\n     * */\n\n    private enabled: Queue<string>;\n    private disabled: string[];\n    private items: { [key: string]: T };\n\n    constructor() {\n        this.enabled = new Queue();\n        this.disabled = [];\n        this.items = {}\n    }\n\n    has( id: string ): boolean {\n        return this.items[id] ? true : false;\n    }\n\n    add( id: string, item: T ): boolean {\n        // if the item is already in the pool\n        if (this.has(id)) this.remove(id);\n        // add to the queue\n        this.enabled.enqueue(id);\n        // add the item to the pool\n        this.items[id] = item;\n        // return true\n        return false;\n    }\n\n    disable(id: string): boolean {\n        if( !this.has(id) ) return false;\n        // if it is in the disable list, job done\n        if( this.disabled.indexOf(id) !== -1 ) return true;\n        // if it is in the enabled list, remove it\n        if( this.enabled.indexOf(id) !== -1 ){\n            this.enabled.remove(id);\n            // add the slave to the disable list\n            this.disabled.push(id);\n            return true;\n        }\n        return false;\n    }\n\n    disableUntil(id: string, timeOrCondition: number | Function): undefined {\n        // if it is not in the pool, return false\n        if( !this.has(id) ) return;\n        // check if timeOrCondition is a number or a function\n        let time = null;\n        let condition : any = null;\n        if(typeof timeOrCondition === 'number')\n            time = timeOrCondition;\n        else if(typeof timeOrCondition === 'function')\n            condition = timeOrCondition;\n        else throw new Error('timeOrCondition must be a number or a function');\n        // if it is already disabled, we want to keep it disabled until the timeOrCondition is met\n        // if it is in the enabled list, disable it\n        if( this.enabled.indexOf(id) !== -1 ) this.disable(id);\n        // check that the id is in the disabled list\n        if( this.disabled.indexOf(id) === -1 ) throw new Error('id is not in the disabled list');\n        // if time is defined, set a timeout\n        if(time) setTimeout(() => this.enable(id), time);\n        // if condition is defined, set a interval\n        if(condition){\n            let interval = setInterval(() => {\n                if(condition()){\n                    clearInterval(interval);\n                    this.enable(id);\n                }\n            }, 100);\n        }\n    }\n\n\n    enable(id: string) : boolean {\n        // if it is not in the pool, return false\n        if( !this.has(id) ) return false;\n        // if it is already enabled, job done\n        if( this.enabled.indexOf(id) !== -1 ) return true;\n        // if it is in the disabled list, remove it\n        if( this.disabled.indexOf(id) !== -1 ){\n            // remove the slave from the disable list\n            this.disabled = this.disabled.filter( e => e !== id );\n            // add the slave to the queue\n            this.enabled.enqueue(id);\n            return true\n        }\n        return false;\n    }\n\n    nextAndEnable() : string | boolean {\n        // if the diabled list is empty, return false\n        if( this.disabled.length === 0 ) return false;\n        // get the first element of the disabled list\n        let id = this.disabled[0];\n        // and enable it\n        this.enable(id);\n        // return the id\n        return id;\n    }\n\n    rotate() : T | null { \n        // dequeue and enqueue\n        if(this.size() === 0) return null\n        const id = this.enabled.dequeue()\n        if(!id) return null\n        this.enabled.enqueue(id)\n        return this.items[id]\n    }\n\n    hasEnabled() : boolean {\n        return this.enabled.size() > 0;\n    }\n\n\n    nextAndDisable() : T | null { // dequeue and disable\n        if(this.size() === 0) return null\n        const id = this.enabled.dequeue();\n        if(!id) return null;\n        this.disabled.push(id);\n        return this.items[id];\n    }\n\n    // remove value while maintaining order\n    remove( id: string ) : T | null {\n        // look in the queue for the id\n        let result = this._lookUp(id);\n        if(result){\n            let index = result.index;\n            let list = result.list;\n            // remove the lists\n            if(list === 'enabled')\n                this.enabled.removeAt(index);\n            else\n                this.disabled.splice(index, 1);\n            // remove the items\n            let item = this.items[id];\n            delete this.items[id];\n            // return true\n            return item;\n        }\n        return null;\n    }\n\n    removeOne() : T | null {\n        // get the first element of the enabled list\n        if(this.enabled.size() > 0){\n            let id = this.enabled.dequeue();\n            if(id === undefined || id === false) return null;\n            // remove the item from the pool\n            let item = this.items[id];\n            delete this.items[id];\n            return item;\n        }\n        return null;\n    }\n\n    get( id: string ) : T | null {\n        /* get the item from the pool */\n        if(!this.has(id)) return null;\n        return this.items[id];\n    }\n\n    // get the size of the pool\n    size() : number {\n        return Object.keys(this.items).length;\n    }\n\n    // lenght of the pool\n    length() : number {\n        return this.size();\n    }\n\n    // count the enabled elements\n    getEnabledCount() : number {\n        return this.enabled.size();\n    }\n\n    // count the disabled elements\n    getDisabledCount() : number {\n        return this.disabled.length;\n    }\n\n    // check if queue is empty\n    isEmpty() : boolean {\n        return this.size() === 0;\n    }\n\n    _lookUp( id : string ) : { index: number, list: string } | false {\n        // look in the queue for the id\n        let index = this.enabled.indexOf(id);\n        if(!(index === -1))\n            return { index, list: 'enabled' };\n        // look in the disable list for the id\n        index = this.disabled.indexOf(id);\n        if(!(index === -1))\n            return { index, list: 'disabled' };\n        return false;\n    }\n\n    toArray() : T[] {\n        return Object.values(this.items);\n    }\n\n    print() : void {\n        console.log(this.toArray());\n    }\n\n    getEnabled() : string[] {\n        return this.enabled.toArray();\n    }\n\n    getEnabledObjects() : T[] {\n        return this.enabled.toArray().map( id => this.items[id] );\n    }\n\n    getDisabled() : string[] {\n        return this.disabled;\n    }\n\n    getDisabledObjects() : T[] {\n        return this.disabled.map( id => this.items[id] );\n    }\n\n    getConnections() : string[] {\n        return Object.keys(this.items);\n    }\n\n    healthCheck() : boolean {\n        let total = this.size();\n        let enabled = this.getEnabled().length;\n        let disabled = this.getDisabled().length;\n        if(total === (enabled + disabled))\n            return true;\n        else return false;\n    }\n\n    // synonims\n    next = this.rotate\n    pop = this.nextAndDisable;\n    shift = this.nextAndEnable;\n    unshift = this.add;\n    push = this.add;\n    count = this.size;\n    removeAt = this.remove;\n    removeItem = this.remove;\n\n\n}\n\nexport default Pool;\n","// if we get debug mode, we will log everything\n\nconst log = (...args : any[]) => {\n    // if we get debug mode in global scope, we will log everything\n    if(process.env.debug === 'true'){\n        let pretext = process.env.type? process.env.type : 'Primary';\n        console.log(`[${pretext}]`, ...args);\n    }\n    else return null;\n};\n\n\nexport default log;\n","import { v4 as uuidv4 } from 'uuid';\n\nconst generateUUID = () => {\n    return uuidv4();\n}\n\n export default generateUUID;\n","/* this function is used to await a condition to be met with a certain interval and timeout\n * until the condition is met or the timeout is reached */\nasync function interval_await(condition: () => any, \n                              timeout: number = 10000,\n                              interval: number = 100) : Promise<any> {\n    return await new Promise( async (resolve, reject) => {\n        let timeout_obj : NodeJS.Timeout \n        let interval_obj : NodeJS.Timeout \n        // set a timeout to reject the promise\n        if(timeout > 0){\n            timeout_obj = setTimeout(() => {\n                clearInterval(interval_obj);\n                reject('timeout');\n            }, timeout);\n        }\n        // set an interval to check the condition\n        interval_obj = setInterval( async  () => {\n            // check if the condition is met\n            let result: Boolean = await condition();\n            if(result === true) {\n                clearInterval(interval_obj);\n                clearTimeout(timeout_obj);\n                resolve(result);\n            }\n        }, interval);\n    }).catch( error => {\n        throw error;\n    });\n}\n\nexport default interval_await;\n","import { SlaveMethods } from '../service/index.js'\nimport { Listener } from '../network/index.js'\n\n/* this function will take a type slaveMethods passed to a Service and return a type Listener */\nfunction toListeners(slaveMethods: SlaveMethods): Listener[] {\n    return Object.keys(slaveMethods).map((key) => ({\n        event: key,\n        parameters: slaveMethods[key].length > 0 ? new Array(slaveMethods[key].length).fill(undefined) : undefined,\n        callback: slaveMethods[key],\n    }));\n\n}\n\nexport default toListeners\n","import * as os from 'os';\nimport * as ip from 'ip';\nimport getPort from 'get-port';\n\ninterface NetworkInterfaceInfo {\n    ip: string;\n    subnet: string;\n}\n\n\nfunction getLocalIpAndSubnet() : NetworkInterfaceInfo[] {\n    const interfaces = os.networkInterfaces();\n    const result = [];\n\n    for (const name of Object.keys(interfaces)) {\n        for (const iface of interfaces[name]!) {\n            if (iface.family === 'IPv4' && !iface.internal) {\n                result.push({ ip: iface.address, subnet: iface.netmask });\n            }\n        }\n    }\n    return result;\n}\n\n\nfunction isSameNetwork(localIp: string, localSubnet: string, targetIp: string) : boolean {\n    const localSubnetInfo = ip.subnet(localIp, localSubnet);\n    const targetSubnetInfo = ip.subnet(targetIp, localSubnet); // Using localSubnet for the mask\n    return localSubnetInfo.networkAddress === targetSubnetInfo.networkAddress;\n}\n\nfunction findLocalIpOnSameNetwork(targetIp: string) : string | null {\n    // if targetIp is localhost, use\n    if(targetIp === 'localhost') targetIp = '127.0.0.1';\n    // if targetIp is in the local network, return the local IP\n    if (ip.isLoopback(targetIp) && ip.isPrivate(targetIp))\n        return targetIp;\n    // Otherwise, find the local IP on the same network\n    const localNetworks = getLocalIpAndSubnet();\n    // for each local network, check if the target IP is in the same network\n    for (const network of localNetworks) {\n        if (isSameNetwork(network.ip, network.subnet, targetIp)) {\n            // return the local IP\n            return network.ip;\n        }\n    }\n    return null;\n}\n\nexport { findLocalIpOnSameNetwork, getLocalIpAndSubnet, getPort };\n","import { log } from './index.js';\nimport { Connection } from '../network/index.js';\n\n/**\n * Checks if a Socket.IO server is running at the specified host and port.\n * @param host - The hostname or IP address of the server.\n * @param port - The port number on which the server is expected to be listening.\n * @param timeout - The maximum time to wait for a response from the server, in milliseconds.\n * @returns A promise that resolves to true if the server is running, otherwise false.\n */\nasync function isServerActive({ name, host, port, timeout }: { \n    name?: string, host: string, port: number, timeout?: number\n}): Promise<boolean> {\n    return new Promise((resolve) => {\n        const connection = new Connection({\n            host,\n            port,\n            id: 'connection_test' + Math.random(),\n            timeout: 10000, // Increased timeout (e.g. 10 seconds)\n            onConnect: (connection: Connection) => {\n                resolve(true);\n                connection.close();\n            }\n\n        });\n        connection.on('connect_error', () => {\n            log(`Connection error to ${name} at ${host}:${port}`);\n        });\n\n        connection.on('connect_timeout', () => {\n            log(`Connection timeout to ${name} at ${host}:${port}`);\n            resolve(false);\n            connection.close();\n        });\n        connection.connected();\n        // Optional: set a manual timeout fallback, in case events fail to fire\n        setTimeout(() => {\n            resolve(false);\n            connection.close();\n        }, 12000); // fallback timeout longer than socket timeout\n    });\n}\n\n\nexport default isServerActive\n","const AsyncFunction = Object.getPrototypeOf(async function(){}).constructor;\n\nasync function runAsyncCode(codeString : string, context = {}) {\n    let userFunc : any\n    if (typeof codeString !== 'string') \n        throw new TypeError('The first argument must be a string of code');\n    if(isCallbackString(codeString)){\n        try { // if we got a callback string, we need to return it as is\n            userFunc = eval(`(${codeString})`);\n            let result = await userFunc(context);\n            return result;\n        } catch (error: any) {\n            throw error;\n        }\n    }\n    try{ // if we have normal code, we make the whole context available\n        userFunc = new AsyncFunction(...Object.keys(context), codeString);\n        const result = await userFunc(...Object.values(context));\n        return result ;\n    } catch (error: any) {\n        throw error;\n    }\n}\n\nfunction isCallbackString(code: string) {\n  try {\n    const fn = eval(`(${code})`);\n    return typeof fn === 'function';\n  } catch (e) {\n    return false;\n  }\n}\n\nexport default runAsyncCode;\n\n","import { Server } from \"socket.io\";\nimport http from \"http\";\nimport { createServer } from \"http\";\nimport { Socket } from \"socket.io\";\nimport { log, Pool } from '../utils/index.js';\nimport type Listener from './types/Listener.js';\nimport Connection from \"./Connection.js\";\n\n\nclass NetworkServer {\n    /* this class will handle the logic managing the server conenctions with clilent, \n     * it will keep track of the node id and it will handle connection and dicoections */\n    private io: Server;\n    private host: string;\n    private port: number;\n    private maxTransferSize: number;\n    private clients: Pool<Connection>;\n    public name: string;\n    public isLan: boolean;\n    public connectionCallback: any;\n    public disconnectCallback: any;\n    public listeners: Listener[];\n    public httpServer?: http.Server;\n    public isReady: boolean;\n    private ioOptions: any;\n\n    constructor({ name, host, port, listeners } : {\n        name: string, host: string, port: number, listeners: Listener[]\n    }, options?: { maxTransferSize: number }) {\n        this.host = host || \"localhost\";\n        this.isLan = this.host !== 'localhost'\n        this.port = port || 0; // zero means random port\n        this.isReady = false;\n        this.maxTransferSize = options?.maxTransferSize || 1e9; // default 1GB\n        this.name = name? name : \"server\";\n        this.connectionCallback = null;\n        this.disconnectCallback = null;\n        this.clients = new Pool<Connection>();\n        this.listeners = listeners || [];\n        this.ioOptions = {\n            maxHttpBufferSize: this.maxTransferSize,\n        };\n        // initiate with the server\n        if(this.isLan){ // if we are in a over lan\n            // create a http server\n            this.httpServer = createServer();\n            this.io = new Server(this.httpServer, this.ioOptions);\n            this.httpServer.listen(this.port, this.host, () => {\n                let address = this.httpServer?.address();\n                if(!address || typeof address === \"string\") {\n                    console.error(\"Server is not running\");\n                    return;\n                }\n                this.isReady = true;\n                this.port = address.port\n            });\n        }else{ // if we are in localhost\n            this.io = new Server(this.port, this.ioOptions);\n            // get the port number\n            this.port = (this.io as any).httpServer.address().port;\n        }\n        // create a new socket.io client instance\n        this.io.on(\"connection\", this.handleConnection.bind(this));\n        this.io.on(\"reconnect\", () => log(\"[Server] on reconnect triggered\"));\n        this.io.on(\"disconnect\", this.handleDisconnection.bind(this));\n        // set the listener on the server socket\n        this.setListeners(this.listeners);\n    }\n\n    private async handleConnection(socket: Socket) {\n       log(\"[Server] got new connection\");\n        // make a new connectection instance\n        let connection = new Connection({ \n            socket, name: this.name, listeners: this.listeners\n        });\n        // await fo connection to be established\n        await connection.connected();\n        // get the id of the connection\n        let id = connection.getTargetId();\n        log(\"[Server] connection id: \", id);\n        // check if id is null\n        if(id == null) throw new Error(\"Connection id is null\");\n        // check if connection already exists\n        if(this.clients.has(id)) {\n            let client = this.clients.remove(id);\n            client && client.close();\n        }\n        // give server listeners to the connection\n        // await connection.setListeners(this.listeners);\n        // add connection to pool\n        this.clients.add(id, connection);\n        // run callback\n        if(this.connectionCallback)\n            this.connectionCallback(connection);\n    }\n\n    private handleDisconnection(socket: Socket) {\n        console.log('[Server] got disconnection from node');\n        let socketId = socket.id\n        console.log('[Server] socket id: ', socketId);\n        // filter every client based on the socket id\n        let conn = this.clients.toArray()\n        .filter((client: Connection) => client.socketId === socketId)[0];\n        // cast conn as type Connection\n        if(conn) {\n            // close the connection\n            conn.close();\n            let id = conn.getTargetId();\n            if(id === undefined) \n                throw new Error(\"Connection id is undefined\");\n            this.clients.remove(conn.getTargetId() as string);\n            // run the disconnect callback\n            if(this.disconnectCallback) \n                this.disconnectCallback(conn);\n        }\n    }\n\n    public setListeners(listeners: Listener[]) {\n        // set the listeners on the server socket\n        listeners.forEach((listener: Listener) => {\n            // run the listener callback and emit the result to the client\n            let callback = async ( ...args: any[] ) => {\n                // run the listener callback\n                let result = await listener.callback(...args);\n                // emit the result to the client\n                this.io.emit(listener.event, result);\n            }\n            // remove any previous listeners\n            this.io.removeAllListeners(listener.event);\n            // set the new listener\n            this.io.on(listener.event, callback);\n        });\n        // store the listeners\n        this.listeners = listeners;\n        // broadcast the new listeners to all clients\n        this.io.emit('_set_listeners', this.listeners);\n    }\n\n    public broadcast(event: string, data: any) {\n        // broadcast an event to all clients\n        this.io.emit(event, data);\n    }\n\n    public addListeners(listeners: Listener[]) {\n        // add a new listener to the server\n        // if we have the same event name, we will overwrite it\n        const eventMap = new Map(this.listeners.map(l => [l.event, l]));\n        listeners.forEach(l => eventMap.set(l.event, l));\n        listeners = Array.from(eventMap.values());\n        // set the listener on the server socket\n        this.setListeners(this.listeners);\n    }\n\n    public getClient(id: string) : Connection | null {\n        return this.clients.get(id);\n    }\n\n    public getClients() : Connection[] {\n        return this.clients.toArray();\n    }\n\n    public onConnection(callback: any) {\n        this.connectionCallback = callback;\n    }\n\n    public onDisconnect(callback: any) {\n        this.disconnectCallback = callback;\n    }\n\n    public getListeners() {\n        // the the listneres from the first client\n        let client = this.clients.toArray()[0];\n        // if client is null return an empty array\n        if(!client) return [];\n        // return the listeners\n        return client.getListeners();\n    }\n\n    async close() {\n        // close all sockets\n        this.io.close();\n    }\n\n}\n\nexport default NetworkServer;\n","import Connection from './Connection.js';\nimport { uuid, log, Pool } from '../utils/index.js';\nimport type Listener from './types/Listener.js';\nimport Server from './Server.js';\n\nclass Network {\n    /* *\n     * this class will handle the connections of a node in the network.\n     * this node can be in either a server or a client.\n     * in a server it will have a Server instance and it will handle the nodes connections\n     * in a client it will have a pool of connections to other servers\n     * Each Node will have a NetworkNode\n     * */\n\n    public id: string;\n    // this is where a node store its server,\n    // which in turn stores its connections to clients\n    public server: Server | null;\n    public name: string;\n    private listeners: Listener[];\n    // this is where we store our connections to servers\n    public connections: Pool<Connection>;\n    // callback for when a new service connection is made\n    public serviceConnectionCallback?: Function;\n    // callback for when a service disconnects\n    public serviceDisconnectCallback?: Function;\n    // callback for when a new listener is added\n    public newListenersCallback?: Function;\n\n\n    constructor({ name = '', id = undefined } : { name?: string, id?: string }) {\n        //log(`[Network][${name}] netowrk created`);\n        this.name = name;\n        this.listeners = [];\n        this.id = id || uuid();\n        this.server = null;\n        this.connections = new Pool();\n        this.serviceConnectionCallback = undefined;\n        this.serviceDisconnectCallback = undefined;\n        this.newListenersCallback = undefined;\n    }\n\n    async connect({ name, host, port, as } : { name?: string, host: string, port: number, as?: string }): Promise<Connection> {\n        /* this function connects to a server instance or a Node Manager\n         * and it keeps track of the conenction by adding it to a pool of server connection\n         * it uses the name as the key in the pool\n         * then run the callback */\n        const connection = new Connection({\n            name : this.name, host, port, id: this.id,\n            onSetListeners: this.newListenersCallback\n        });\n        // await connection and handshake\n        await connection.connected();\n        // get the name of the target service\n        let server_name = connection.getTargetName();\n        if(server_name === undefined)\n            throw new Error('Server name is undefined');\n        if(name !== undefined) // check if the name is the same\n            if(server_name !== name)\n                throw new Error(`Server name mismatch: ${server_name} !== ${name}`);\n        // if we are saving the connection as a different name\n        if(as !== undefined) server_name = as;\n        // if we already have a connection with the same id, remove it\n        if(this.connections.has(server_name)) {\n            let conn = this.connections.remove(server_name);\n            conn && conn.close();\n        }\n        // add the listeners to the new connection\n        connection.setListeners(this.listeners);\n        // add the new connection\n        this.connections.add(server_name, connection);\n        // new connection callback\n        this.serviceConnectionCallback && this.serviceConnectionCallback(connection);\n        // return the connection\n        return connection;\n    }\n\n    public async connectAll(services: { name: string, host: string, port: number }[]) {\n        log(`[Network][${this.name}] connecting to all services`, services);\n        // connect to all the services\n        let connections = await Promise.all(services.map(\n            async service => await this.connect({\n                name: service.name,\n                host: service.host,\n                port: service.port\n            })\n        )).catch((err) => {\n            log(`[Network][${this.name}] error connecting to services:`, err);\n            return [];\n        })\n        //log(`[Network][${this.name}] returning connections:`, connections);\n        return connections;\n    }\n\n    public createServer(\n        name: string, host: string, port: number,\n        listeners: Listener[] = []\n    ) {\n        // the server keeps track of it client connections\n        this.server = new Server({ name, host, port, listeners });\n    }\n\n    public close() {\n        // if we have a server we close it\n        if(this.server){\n            this.server.close()\n        }\n        // close all the connections\n        this.connections.toArray().forEach((connection: Connection) => {\n            connection.close();\n        });\n    }\n\n    public getService(name: string): Connection {\n        // get the service connection\n        let service = this.connections.get(name);\n        // if the service is not found we throw an error\n        if(service === null)\n            throw new Error(`Service ${name} not found for ${this.name}`);\n        return service;\n    }\n\n    public getServices(): Connection[] {\n        // get all the clients that are services types\n        return this.connections.toArray();\n    }\n\n    public getNode(id: string): Connection {\n        // get the client that is a node type\n        if(this.server === null) throw new Error('Server is not created');\n        let client = this.server.getClient(id);\n        // throw an error if the client is not found\n        if(client === null) throw new Error('Client not found');\n        // return the client\n        return client;\n    }\n\n    public getNodes(): Connection[] {\n        // get all the clients that are nodes types\n        let nodes = this.server?.getClients().\n            filter((conn: Connection) => conn.targetType === 'client');\n        return nodes || [];\n    }\n\n    public getConnections(): Connection[] {\n        // get all the connections\n        return this.connections.toArray().concat(this.server?.getClients() || []);\n    }\n\n    public closeService(name: string) {\n        // close the connection\n        let connection = this.connections.remove(name);\n        if(connection) connection.close();\n        // callback\n        this.serviceDisconnectCallback &&\n            this.serviceDisconnectCallback(connection);\n    }\n\n    public closeConnection(id: string) {\n        // close the connection\n        let connection = this.connections.remove(id);\n        if(connection) connection.close();\n    }\n\n    public registerListeners(listeners: Listener[]) {\n        /* this function registers the listeners to the network and overwrites the old ones */\n        //log(`[Network][RegisterListners][${this.name}]`, listeners);\n        //log(`[Network][RegisterListners][${this.name}] connections:`, this.connections);\n        // store the listeners\n        this.listeners = listeners;\n        // if we have a server created we pass the listeners to it\n        if(this.server) this.server.setListeners(this.listeners);\n        // for every conenction in out pool we register the listeners\n        this.connections.toArray().forEach((connection: Connection) => {\n            connection.setListeners(listeners);\n        });\n    }\n\n\n    public addListeners(listeners: Listener[]) {\n        /* this function adds the listeners to the network */\n        this.listeners = this.listeners.concat(listeners);\n        // if we have a server created we pass the listeners to it\n        if(this.server) this.server.addListeners(listeners);\n        // for every conenction in out pool we register the listeners\n        this.connections.toArray().forEach((connection: Connection) => {\n            connection.addListeners(listeners);\n        });\n\n    }\n\n    public getRegisteredListeners(): any {\n        // get the listeners from the server\n        let server_listeners = this.server?.getListeners() || [];\n        let connections_listeners = this.connections.toArray().map((connection: Connection) => {\n            log('inside loop conenction:', connection);\n            return { id: connection.id, listeners: connection.getListeners() };\n        });\n        // return the listeners\n        return { server: server_listeners, connections: connections_listeners };\n    }\n\n\n    /* callbacks */\n    public onNodeConnection(callback: (connection: Connection) => void) {\n        if(this.server === null) throw new Error('Server is not created');\n        this.server.onConnection(callback);\n    }\n\n    public onNodeDisconnect(callback: (connection: Connection) => void) {\n        if(this.server === null) throw new Error('Server is not created');\n        this.server.onDisconnect(callback);\n    }\n\n    public onServiceConnection(callback: (connection: Connection) => void) {\n        // set the network listners to the connection\n        this.serviceConnectionCallback = callback;\n    }\n\n    public onServiceDisconnect(callback: (connection: Connection) => void) {\n        this.serviceDisconnectCallback = callback;\n    }\n\n    public onNewListeners(callback: (listeners: Listener[]) => void) {\n        this.newListenersCallback = callback;\n    }\n\n}\n\nexport default Network;\n","import Network from './Network.js';\nimport Connection from './Connection.js';\nimport type { Listener } from './types/index.js';\n\nexport default Network;\n\nexport { Listener, Connection };\n","import { fork } from 'child_process';\nimport process from 'node:process';\n\n\ntype SpawnOptions = {\n    numberOfSpawns?: number;\n    allowedToSpawn?: boolean;\n    spawnOnlyFromPrimary?: boolean;\n    metadata?: any;\n}\n\nclass Cluster {\n    numberOfProcesses: number;\n    process_timeout: number;\n    crash_on_error: boolean;\n    thisProcess: any;\n    type: string;\n    processes: any[];\n    allowedToSpawn: boolean;\n    spawnOnlyFromPrimary: boolean;\n    debugging: boolean;\n\n    constructor(options:any) {\n        this.numberOfProcesses = options.numberOfProcesses || null;\n        this.process_timeout = options.process_timeout || null;\n        this.crash_on_error = options.crash_on_error || false;\n        this.debugging = options.debugging || false;\n        this.type = process.env.type || 'primary';\n        this.allowedToSpawn = process.env.allowedToSpawn === 'true' || false;\n        this.spawnOnlyFromPrimary = false;\n        this.thisProcess = process;\n        this.processes = [];\n    }\n\n\n    public spawn( process_type: string , {\n        numberOfSpawns, allowedToSpawn, spawnOnlyFromPrimary, metadata \n    }: SpawnOptions = {}){\n        this.log('Spawning new process ' + process_type);\n        this.log(`allowedToSpawn: ${allowedToSpawn}`);\n        this.log('this.amIThePrimaryProcess(): ' + this.amIThePrimaryProcess());\n        if(numberOfSpawns === undefined) numberOfSpawns = 1;\n        this.spawnOnlyFromPrimary = spawnOnlyFromPrimary || false;\n        // this makes it so that only the primary process can pass the ability to spawn new processes\n        // to another process, otherwise there will be an infinite loop\n        if(this.amIThePrimaryProcess() && allowedToSpawn) allowedToSpawn = true;\n        else allowedToSpawn = false;\n        this.log('final passing on allowedToSpawn ' + allowedToSpawn)\n        // check if the process is allowed to spawn new processes\n        if(this.isProcessAllowedToSpawn() === false) return;\n        let curProcess;\n        for (let i = 0; i < numberOfSpawns; i++){\n            curProcess = fork(\n                process.argv[1], [], {\n                    env: {\n                        is_child: 'true',\n                        type: process_type,\n                        allowedToSpawn: `${allowedToSpawn}`,\n                        metadata: JSON.stringify(metadata)\n                    }\n                }\n            )\n            this.processes.push(curProcess);\n        }\n    }\n\n\n    private isProcessAllowedToSpawn(){\n        if(this.spawnOnlyFromPrimary && this.amIChildProcess()) \n            return false;\n        if(this.amIThePrimaryProcess()){\n            this.log('Primary process is allowed to spawn new processes');\n            return true;\n        }else this.log('Process is not the primary process');\n        if(this.allowedToSpawn){\n            this.log('Process is allowed to spawn new processes');\n            return true;\n        }else this.log('Process is not allowed to spawn new processes');\n        return false;\n    }\n\n\n    get_this_process() {\n        return this.thisProcess;\n    }\n\n\n    get_processes() {\n        return this.processes;\n    }\n\n    public is(process_type: string) {\n        this.log(`checking if is process ${process_type}`);\n        if(process_type === 'primary') return this.amIThePrimaryProcess();\n        return process.env.type === process_type;\n    }\n\n    private amIThePrimaryProcess() {\n        if (this.thisProcess.env.is_child === undefined)\n            return true;\n        if(this.thisProcess.env.is_child === null)\n            return true;\n        if (this.thisProcess.env.is_child === 'false')\n            return true;\n        return false;\n    }\n\n    public isPrimary() {\n        return this.amIThePrimaryProcess();\n    }\n\n    private amIChildProcess() {\n        return process.env.is_child === 'true';\n    }\n\n    private log(message: string) {\n        this.debugging && console.log(`[${process.pid}][${this.type}] ${message}`);\n    }\n\n    public getMetadata() {\n        return process.env.metadata;\n    }\n\n}\n\nexport default Cluster;\n","import Cluster from './ProcessCluster.js'\nexport default Cluster\n\n","import Network, { Listener } from '../../network/index.js';\nimport Cluster from '../../cluster/index.js';\nimport type { ServiceAddress } from '../../service/index.js';\n//import { log } from '../../utils/index.js';\n\ntype Parameters = {\n    host: string,\n    port: number,\n};\n\nclass PeerDicoveryServer {\n    /* This will be the based class for the service which salvery will call to create proceses */\n    public name: string; \n    public host: string;\n    public port: number;\n    private cluster: Cluster | null = null;\n    private network: Network | null = null;\n    private services: { [key: string]: ServiceAddress } = {};\n\n    constructor(params: Parameters) {\n        this.name = 'peer_discovery';\n        // the address of the service will take\n        this.host = params.host;\n        this.port = params.port;\n    }\n\n    public async start() { \n        // let initlize the cluster\n        this.cluster = new Cluster({ name: this.name });\n        this.cluster.spawn(this.name, {\n            spawnOnlyFromPrimary: true // make sure that only one the primary process can spawn this service\n        });\n        // run the peer discovery service\n        if(this.cluster.is('peer_discovery')){\n            //log(`starting peer discovery service...`);\n            // now we will create the network\n            this.network = new Network({name: this.name + '_network'});\n            // get the listneres\n            let listeners = this.getListeners();\n            // create the server\n            this.network.createServer(this.name, this.host, this.port, listeners);\n        }\n        return;\n    }\n\n    private getListeners(): Listener[] {\n        // this will be the listeners for the peer discovery service\n        // this is the eonly traffic that the server will have.\n        let listeners = [{\n            // get number of nodes\n            event: 'register_service',\n            params: ['name', 'host', 'port'],\n            callback: this.registerService.bind(this)\n        },{\n            event: 'get_services',\n            callback: this.getServices.bind(this)\n        },{\n            event: 'remove_service',\n            params: ['name'],\n            callback: this.removeService.bind(this)\n        },{ // select individual nodes, or groups of nodes\n            event: 'exit',\n            callback: this.exit.bind(this)\n        }];\n        return listeners;\n    }\n\n    private registerService({ name, host, port }: ServiceAddress) {\n        if(this.network === null) throw new Error('Network is not initialized');\n        // check if the service is already registered\n        if(this.services[name]) throw new Error(`Service ${name} is already registered`);\n        // add the service to the list of services\n        this.services[name] = { name, host, port };\n        // broadcast the new service to all the nodes\n        if(this.network === null) throw new Error('Network is not initialized');\n        if(this.network.server === null) throw new Error('Server is not initialized');\n        this.network.server.broadcast('new_service', { name, host, port });\n        return;\n    }\n\n    private getServices() : ServiceAddress[] {\n        return Object.values(this.services);\n    }\n\n    private removeService(name: string) {\n        if(!this.services[name]) return false;\n        if(this.network === null) throw new Error('Network is not initialized');\n        if(this.network.server === null) throw new Error('Server is not initialized');\n        // remove the service from the list of services\n        delete this.services[name];\n        // broadcast the removal of the service\n        this.network.server.broadcast('remove_service', { name });\n        return true;\n    }\n\n\n    public exit(){\n        //log(`[${this.name}] will exit in 1 seconds`);\n        setTimeout(() => {\n            if(this.network) this.network.close();\n            // lastly we close ourselves, how sad\n            process.exit(0);\n        }, 1000);\n        return true\n    }\n\n}\n\n\n\nexport default PeerDicoveryServer;\n","import Network from '../../network/index.js';\nimport { log } from '../../utils/index.js';\n\ntype params = {\n    name?: string,\n    host: string,\n    port: number,\n}\n\n\nclass PeerDiscoveryClient {\n    /* this class will be used to connect to a the peer discovery server */\n    public name: string = 'peer_discovery';\n    public host: string;\n    public port: number;\n    public network?: Network = new Network({ name: 'peer_discovery' });\n    // the time we give every service to register, before we get the services\n    public windowTime = 2000; // 2 seconds\n    // get the network from the connection\n    constructor({ host, port, name }: params) {\n        this.name = name || 'peer_discovery';\n        this.host = host;\n        this.port = port;\n    }\n\n    public async connect(){\n        // connect to server\n        if(this.network === undefined) throw new Error('Network not set');\n        await this.network.connect({\n            name: this.name,\n            host: this.host,\n            port: this.port,\n        });\n    }\n\n    public async register({ host, port, name }: params) {\n        if(this.network === undefined) throw new Error('Network not set');\n        let connection = this.network.getService(this.name);\n        if(connection === null) throw new Error(`Service ${this.name} not found`);\n        return await connection.send('register_service', { host, port, name });\n    }\n\n    public async getServices() {\n        // await for the window time\n        await new Promise((resolve) => setTimeout(resolve, this.windowTime));\n        if(this.network === undefined) throw new Error('Network not set');\n        let connection = this.network.getService(this.name);\n        if(connection === null) throw new Error(`Service ${this.name} not found`);\n        let services = await connection.send('get_services');\n        return services;\n    }\n\n    public async exit() {\n        if(this.network === undefined) throw new Error('Network not set');\n        let connection = this.network.getService(this.name);\n        if(connection === null) throw new Error(`Service ${this.name} not found`);\n        return await connection.send('exit');\n    }\n\n}\n\nexport default PeerDiscoveryClient;\n","import PeerDiscoveryServer from './PeerDiscoveryServer.js';\nimport PeerDiscoveryClient from './PeerDiscoveryClient.js';\n\nexport default PeerDiscoveryServer;\n\nexport { PeerDiscoveryClient };\n","/* \n * this code will serve as the entry point for the applacation\n * it allows the api to have a syntax of:\n *\n * proxy\n *  .master( (master) => {\n *      console.log(master)\n *      console.log('some function')\n *  })\n *  .slave( slave => {\n *      console.log('something else', slave)\n *  }, 9090, 'someArgString')\n *  .yetAnotherMethod();\n */\n\n\n/*  this function will make the proxy object which takes a callback\n *  and returns a proxy object\n *  @param {function} callback - the callback to be called\n */\n\n// this is a promise \ntype proxyObjectCallback =  (methodCalled: string, param1: any, param2?: any, param3?: any) => void | Promise<void>;\n\nlet proxy: ProxyConstructor;\n\nconst makeProxyObject = (callback: proxyObjectCallback) => {\n    // Create a proxy object handler the given callbakcs\n    const proxyObjecHandler = makeProxyObjecHandler(callback);\n    proxy = new Proxy({}, proxyObjecHandler);\n    return proxy;\n}\n\nconst makeProxyObjecHandler = (callback: proxyObjectCallback) => ({\n    get(target: any, prop: any) {\n        // this will take\n        return (args: any, args2?: any, args3?: any) => {\n            let method = prop;\n            let param1 = args;\n            let param2 = args2;\n            let param3 = args3;\n            // if the first argument not a function or an object\n            if(typeof args !== 'function' && typeof args !== 'object')\n                throw new Error('first parameter must be a function or an object')\n            if(args2 !== undefined && typeof args2 !== 'object') \n                throw new Error('second parameter must be an object')\n            if(args3 !== undefined && typeof args3 !== 'object')\n                throw new Error('third parameter must be an object')\n            // run the passed callback\n            callback(method, param1, param2, param3);\n            // return the proxy object\n            return proxy;\n        };\n    }\n});\n\nexport default makeProxyObject;\n","import Network, { Listener, Connection } from '../network/index.js';\nimport { ServiceClient } from '../service/index.js';\nimport type { ServiceAddress } from './types/index.js';\nimport { await_interval, execAsyncCode, log } from '../utils/index.js';\nimport { serializeError, deserializeError } from 'serialize-error';\n\n/*\n * this class will basicaly connect to all of the services given to it by the primary service.\n * 1.- attempt to make a conenction the primary service passed by the server\n * 2.- it will take a list of services\n\n/* this calss will make a slave type which will be an a child of the Node class\n * this is the class that will be used to run the the client of a node\n * like other classes it will work as both\n * the server connection to the client and the client conenction to the server.\n * this class will have a list of methods that will be converted to listeners\n * and a list of listeners that will be converted to methods\n */\n\ntype NodeStatus = 'idle' | 'working' | 'error';\n\nclass Node {\n    public mode: 'client' | 'server' | undefined  = undefined;\n    public id: string | undefined = undefined;\n    public status: NodeStatus = 'idle';\n    public listeners: Listener[] = [];\n    public lastUpdateAt: number = Date.now();\n    public network: Network | undefined = undefined;\n    public servicesConnected: boolean = false;\n    // fields when the class is client handler on a service\n    public statusChangeCallback: ((status: NodeStatus, node: Node) => void) | null = null;\n    // stash changes functions\n    public stashSetFunction: (({ key, value }: { key: string, value: any }) => any) | null = null;\n    public stashGetFunction: ((key: string) => any) | null = null;\n    // fields when the class is a service handler on a node\n    public services: ServiceAddress[] = [];\n    public doneMethods: { [key: string]: boolean } = {};\n    public methods: { [key: string]: (parameter?: any, self?: Node) => any } = {};\n\n    constructor(){}\n\n    /* this function will work on any mode the class is on */\n\n    public getId = () => this.id;\n    public getStatus = () => this.status;\n    public lastHeardOfIn = () => Date.now() - this.lastUpdateAt;\n    public isIdle = () => this.status === 'idle';\n    public isWorking = () => this.status === 'working';\n    public isError = () => this.status === 'error';\n    private updateLastHeardOf = () => this.lastUpdateAt = Date.now();\n    private updateStatus = (status: NodeStatus) => this.status = status;\n    public untilFinish = async () => { // await until the node is idle\n        await await_interval(() => this.isIdle(), 1000)\n        .catch(() => { throw new Error('The node is not idle') })\n        return true;\n    }\n\n    public run = async (method: string, parameter: any) => {\n        if(this.mode === 'client') return await this.run_client({ method, parameter });\n        else if(this.mode === 'server') return await this.run_server({ method, parameter });\n        else throw new Error('The mode has not been set');\n    }\n\n    public exec = async (method: string, code: string) => {\n        if(this.mode === 'client') return await this.exec_client(code);\n        else if(this.mode === 'server') return await this.exec_server(code);\n        else throw new Error('The mode has not been set');\n    }\n\n    public setServices = async (services: ServiceAddress[]) => {\n        if(this.mode === 'client') return await this.setServices_client(services);\n        else if(this.mode === 'server') return await this.setServices_server(services);\n        else throw new Error('The mode has not been set');\n    }\n\n    public exit = async () => {\n        if(this.mode === 'client') return await this.exit_client();\n        else if(this.mode === 'server') return await this.exit_server();\n        else throw new Error('The mode has not been set');\n    }\n\n    public ping = async () => {\n        if(this.mode === 'client') return await this.ping_client();\n        else if(this.mode === 'server') return await this.ping_server();\n        else throw new Error('The mode has not been set');\n    }\n\n    /* this functions will set the Node.ts as a client handler for the server */\n    public setNodeConnection(connection: Connection, network: Network){\n        if(this.mode !== undefined && this.mode !== null )\n            throw new Error('The node mode has already been set');\n        // set the mode as a server client hander\n        this.mode = 'server';\n        // get the node id from the conenction\n        this.id = connection.getTargetId();\n        // set the network\n        this.network = network;\n        // define the listners which we will be using to talk witht the client node\n        if(this.stashSetFunction === null || this.stashGetFunction === null )\n            throw new Error('The stash functions have not been set');\n        // set the listeners\n        this.listeners = [//  this callbacks will run when we recive this event from the client node\n            { event: '_set_status', parameters: ['status'], callback: this.handleStatusChange.bind(this) },\n            { event: '_ping', parameters: [], callback: () => '_pong' },\n            { event: '_set_stash', parameters: ['key', 'value'], callback: this.stashSetFunction },\n            { event: '_get_stash', parameters: ['key'], callback: this.stashGetFunction },\n        ]\n            // register the listeners on the connection\n            connection.setListeners(this.listeners);\n    }\n\n    public setStatusChangeCallback(callback: (status: NodeStatus, node: Node) => void){\n        this.statusChangeCallback = callback;\n    }\n\n    public setStashFunctions({ set, get }: { set: (key: string, value: any) => any, get: (key: string) => any }){\n        this.stashSetFunction = ({ key, value }: { key: string, value: any }) => set(key, value);\n        this.stashGetFunction = get;\n    }\n\n    public handleStatusChange(status: NodeStatus){\n        // set status as status and call the callback\n        this.updateStatus(status);\n        this.statusChangeCallback && this.statusChangeCallback(status, this);\n    }\n\n    public lastHeardOf(){\n        // this function will be called when the client node tells us that it is working\n        this.updateLastHeardOf();\n        return this.lastHeardOfIn();\n    }\n\n    private async run_server({method, parameter}: {method: string, parameter: any}){\n        // this function will send the node a method to be run in the client\n        // set the status to working\n        this.handleStatusChange('working');\n        let res = await this.send('_run', { method, parameter });\n        // set the status to idle\n        this.handleStatusChange('idle');\n        // if there is an error\n        if(res.isError === true)\n            res.error = deserializeError(res.error);\n        // return the result\n        return res\n    }\n\n    private async exec_server(code: string){\n        // this function will send the node a code to be run in the client\n        // set the status to working\n        this.handleStatusChange('working');\n        let res = await this.send('_exec', code);\n        // set the status to idle\n        this.handleStatusChange('idle');\n        // if there is an error\n        if(res.isError === true)\n            res.error = deserializeError(res.error);\n        // return the result\n        return res\n    }\n\n    private async setServices_server(services: ServiceAddress[]){\n        // this function will send send a list of services to the client node\n        let res = await this.send('_set_services', services);\n        return res;\n    }\n\n    public async ping_server(){\n        // this function will ping the client node\n        let res = await this.send('_ping');\n        if(res === 'pong') this.updateLastHeardOf();\n        return true;\n    }\n\n    public async exit_server(){\n        // this function tell the node client to exit\n        let res = await this.send('_exit', null)\n        // we catch the timeout erro scince the client node will exit\n        .catch((error) => { if(error === 'timeout') return true; else throw error; });\n        return res\n    }\n\n    public async registerServices(service: ServiceAddress[]){\n        // for every service we need to send the service address to the client node\n        let services = service.map(service => new Promise(async (resolve) => {\n            let result = await this.send('_connect_service', service);\n            resolve(result);\n        }));\n        // await until they are all connected\n        return await Promise.all(services);\n    }\n\n    public async send(method: string, parameter: any = null){\n        // fucntion for sending a method to the client node\n        if(this.network === undefined) throw new Error('The network has not been set');\n        if(this.id === undefined) throw new Error('The id has not been set');\n        if(this.mode === undefined) throw new Error('The mode has not been set');\n        // get the connection of which we will send the method\n        let connection: Connection | undefined = undefined;\n        if(this.mode === 'server')\n            connection = this.network.getNode(this.id);\n        else if(this.mode === 'client')\n            connection = this.network.getService('master');\n        if(connection === undefined)\n            throw new Error('Could not get the conenction from the network');\n        // send the method to the node\n        return await connection.send(method, parameter);\n    }\n\n\n    /* this function will be called when the client node tells us that it is working */\n    public async connectToMaster(host: string, port: number){\n        // conenct the master process which will tell us what to do\n        // create an id for the node\n        this.id = this.id || Math.random().toString(36).substring(4);\n        this.network = new Network({name: 'node', id: this.id});\n        // form the conenction with the master\n        this.network.connect({ host, port, as: 'master' });\n        // set the mode as a client\n        this.mode = 'client';\n        // set the listeners which we will us on the and the master can call on\n        this.listeners = [\n            { event: '_run', parameters: ['method', 'parameter'], callback: this.run_client.bind(this) },\n            { event: '_exec', parameters: ['code_string'], callback: this.exec_client.bind(this) },\n            { event: '_set_services', parameters: ['services'], callback: this.setServices_client.bind(this) },\n            { event: '_is_idle', parameters: [], callback: this.isIdle.bind(this) },\n            { event: '_is_busy', parameters: [], callback: this.isBusy.bind(this) },\n            { event: '_has_done', parameters: ['method'], callback: this.hasDone.bind(this) },\n            { event: '_ping', parameters: [], callback: () => 'pong' },\n                { event: '_exit', parameters: [], callback: this.exit_client.bind(this) }\n        ];\n        // register the listeners on the network\n        this.network.registerListeners(this.listeners);\n    }\n\n    private async run_client({method, parameter}: {method: string, parameter: any}){\n        // this function will be called by the a service or another node to run a function\n        // wait until services are connected, with timeout of 10 seconds\n        await await_interval(() => this.servicesConnected, 10000).catch(() => {\n            throw new Error(`[Node][${this.id}] Could not connect to the services`);\n        })\n        try {\n            // set the status to working\n            this.updateStatus('working');\n            // get the services that we have connected to\n            let services = this.services.map(\n                (s: ServiceAddress) => new ServiceClient(s.name, this.network as Network)\n            ).reduce((acc: any, s: ServiceClient) => {\n                acc[s.name] = s;\n                return acc;\n            }, {})\n            // run method\n            const result = await this.methods[method](parameter, { ...services, slave: this, self: this });\n            // set has done method\n            this.doneMethods[method] = true;\n            // return the result\n            return { result, isError: false };\n        } catch(error){ // serilize the error\n            this.updateStatus('error');\n            // return the error\n            return { error: serializeError(error), isError: true };\n        } finally {\n            // set the status to idle\n            this.updateStatus('idle');\n        }\n    }\n\n\n    private async exec_client(code_string: string){\n        /* this function will execute some passed albitrary code */\n        // check if the code_string is a string\n        if(typeof code_string !== 'string')\n            return { isError: true, error: serializeError(new Error('Code string is not a string')) }\n        // await until service is connected\n        await await_interval(() => this.servicesConnected, 10000).catch(() => {\n            throw new Error(`[Service] Could not connect to the services`);\n        })\n        let services = this.services.map(\n            (s: ServiceAddress) => new ServiceClient(s.name, this.network as Network)\n        ).reduce((acc: any, s: ServiceClient) => {\n            acc[s.name] = s;\n            return acc;\n        }, {})\n        let parameter = { ...services, master: this, self: this };\n        try {\n            // run the albitrary code\n            let result = await execAsyncCode(code_string, parameter);\n            return { result: result, isError: false };\n        } catch(e)  {\n            return { isError: true, error: serializeError(e) }\n        }\n    }\n\n    public async _startup(){\n        // this function should not be here, and Node class should be self contained\n        // thus this class need an outside class to call it, after it has set up its\n        // addMethods and setServices and connectToMaster functions have run.\n        if(this.methods['_startup'] !== undefined)\n            await this.run_client({ method: '_startup', parameter: null });\n    }\n\n    // this function will communicate with the master node and set the stash in that moment\n    public setStash = async (key: any, value: any = null) => await this.send('_set_stash', { key, value });\n    public getStash = async (key: string = '') => await this.send('_get_stash', key);\n\n    public addMethods(methods: { [key: string]: (parameter: any) => any }){\n        // we add the methods to this class\n        this.methods = methods;\n        // populate methods done\n        for(let method in methods)\n            this.doneMethods[method] = false;\n    }\n\n\n    private async setServices_client(services: ServiceAddress[]){\n        // we get the list of services that we need to connect to\n        this.services = services;\n        // connect to the services\n        for(let service of services){\n            let res = await this.connectService(service);\n            if(!res)\n                console.error('Could not connect to the service, ', service.name);\n            else\n                log(`[Node][${this.id}] Connected to the service, ${service.name}`);\n        }\n        this.servicesConnected = true;\n        return true\n    }\n\n    public async connectService({ name, host, port }: ServiceAddress){\n        /* this is the client inplementation.\n         * it will connect to the service and create methods\n         * for every listener that the service has */\n        if(!host || !port)\n            throw new Error('The service information is not complete');\n        // check if there is a service already running on the port and host\n        if(this.network === undefined)\n            throw new Error('The network has not been set');\n        return await this.network.connect({name, host, port});\n    }\n\n    private async ping_client(){\n        // this function will ping the master node\n        let res = await this.send('_ping');\n        if(res === '_pong') this.updateLastHeardOf();\n        return true;\n    }\n\n    private async exit_client(){\n        // before we bail we must be nice enough to close our connections\n        setTimeout(async () => {\n            // if there is a _cleanup method defined\n            if(this.methods['_cleanup'] !== undefined)\n                await this.run_client({ method: '_cleanup', parameter: null });\n            // we close the connections we have,\n            if(this.network !== undefined) this.network.close();\n            // then we exit the process\n            process.exit(0);\n        }, 1000);\n        return true\n    }\n\n    public getListeners(){\n        if(this.network === undefined) throw new Error('The network has not been set');\n        if(this.id === undefined) throw new Error('The id has not been set');\n        let listeners = [];\n        let connection: Connection | undefined = undefined;\n        if(this.mode === 'server'){\n            connection = this.network.getNode(this.id);\n            listeners = connection.getListeners();\n        }else if(this.mode === 'client'){\n            connection = this.network.getNode('master');\n            listeners = connection.getListeners();\n            if(connection === undefined)\n                throw new Error('Could not get the conenction from the network');\n        }\n        return listeners;\n    }\n\n    public hasDone(method: string){\n        return this.doneMethods[method] || false;\n    }\n\n    /* method synonims */\n    public isBusy = this.isWorking;\n    public hasFinished = this.hasDone;\n    public hasError = this.isError;\n    public toFinish = this.untilFinish;\n    public set = this.setStash;\n    public get = this.getStash;\n    public stash = this.setStash;\n    public unstash = this.getStash;\n}\n\n\nexport default Node;\n","import Cluster from '../cluster/index.js';\nimport Network, { Connection } from '../network/index.js';\nimport Node from './Node.js';\nimport { ServiceAddress, Stash } from '../service/index.js';\nimport { Pool, await_interval, log } from '../utils/index.js';\n\n/* this class is created to manage the nodes socket conenctions on a service,\n * it will handle new conenction fron node, and will remove them when they are disconnected\n * this class provide an interface for other classes to interact with all the nodes\n * if a class wants to run a function on each difrent node,\n * if a class wants to broadcast a message to all the nodes\n * if a class want to get the next idle node,\n * or the number of node connected to the network\n * or the number of node that have been disconnected\n * or which are currently busy, or idle, etc\n */\n\ntype Options = {\n    // name of the service\n    name: string,\n    // the host and port of the service\n    host: string,\n    port: number,\n    // the number of processes that will be started on each node\n    number_of_nodes?: number,\n    max_number_of_nodes?: number,\n    min_number_of_node?: number,\n    // the number of request that have to be in queue before increasing the number of processes\n    increase_node_at_requests?: number,\n    // the number of node that have to be idle before decreasing the number of processes\n    decrease_node_at_idles?: number,\n    // you can pass the stash object to the node manager\n    stash?: Stash,\n}\n\nclass NodeManager {\n    private name: string;\n    private network: Network;\n    //private heartBeat: number = 1000;\n    private nodes: Pool<Node> = new Pool();\n    private options: Options;\n    private cluster = new Cluster({});\n    private stash: Stash | null;\n\n\n    constructor(options: Options) {\n        this.name = options.name;\n        this.options = options;\n        this.network = new Network({ name: this.name + '_node_manager' });\n        // create server\n        this.network.createServer(\n            this.name + '_node_manager',\n            this.options.host,\n            this.options.port\n        );\n        // handle when new node is connected\n        this.network.onNodeConnection(this.handleNewNode.bind(this));\n        // handle when a node is disconnected\n        this.network.onNodeDisconnect(this.handleNodeDisconnect.bind(this));\n        // set the stash\n        this.stash = options.stash || null;\n  }\n\n  private handleNewNode(connection: Connection) {\n      /* this function is called when a new node is connected to the master */\n      log('[Node manager] Got a new connectection from a node');\n      // create a new node\n      let node = new Node();\n      // set the functions for the stash of objects\n      node.setStashFunctions({\n          get: async (key: string) => await this.stash?.get(key),\n          set: async (key: string, value: any) => await this.stash?.set(key, value),\n      });\n      // set the connection to the node\n      node.setNodeConnection(connection, this.network);\n      // add callback on status change\n      node.setStatusChangeCallback(this.handleStatusChange.bind(this));\n      // get the id of the node\n      let id = node.getId();\n      if(id === undefined) throw new Error('node id is undefined');\n      // add to the pool\n      this.nodes.add(id, node);\n      // add to the enabled pool\n      this.setIdle(id);\n  }\n\n\n  private handleNodeDisconnect(connection: Connection) {\n      // get the node id\n      let id = connection.getId();\n      if(id === undefined) throw new Error('node id is undefined');\n      // remove the node from the pool\n      this.nodes.remove(id);\n  }\n\n  private handleStatusChange(status: string, node: Node) {\n      // if the node is idle add it to the enabled pool\n      // if the node is busy add it to the disabled pool\n      if(!status) throw new Error('status is undefined');\n      let id = node.getId();\n      if(id === undefined) throw new Error('node id is undefined');\n      if(node.isIdle() || node.isError())\n          this.setIdle(id);\n      else if(node.isBusy())\n          this.setBusy(id);\n      else\n          throw new Error('invalid node status');\n  }\n\n  public async getIdle(node_id: string = '') : Promise<Node> {\n      /* this function return a node that is idle */\n      if(node_id !== '') { // we are looking for a specific node on the pool\n          let node = this.getNode(node_id);\n          // await for seelcted node to be idle\n          await await_interval(() => node.isIdle(), 60 * 60 * 60 * 1000).catch(() => {\n              throw new Error(`timeout of one hour, node ${node_id} is not idle`);\n          });\n          return node;\n      }\n      // check if there are nodes in the pool\n      if(this.nodes.isEmpty())\n          log('[node manager] (WARNING) no nodes found');\n      // await until we get a node which is idle\n      // 0 will make it wait for every for a idle node\n      await await_interval(() => this.nodes.hasEnabled(), 0)\n      .catch(() => { throw new Error('timeout of 10 seconds, no idle node found') });\n      //log('[node manager] got idle node');\n      // get the next node\n      let node = this.nodes.pop();\n      if(node === null) throw new Error('node is null');\n      // return the node\n      return node\n  }\n\n  public getBusy(){\n      // returned a single busy node\n      return this.nodes.getDisabled().pop();\n  }\n\n  public getIdleNodes() : Node[] {\n      /* this function return the nodes which are idle */\n      return this.nodes.getEnabledObjects();\n  }\n\n  public getBusyNodes() : Node[] {\n      /* this function return the nodes which are busy */\n      return this.nodes.getDisabledObjects();\n  }\n\n  public async forEach(callback: (node: Node) => void) {\n      let nodes = this.nodes.toArray();\n      // for each node, make a promise\n      let promises = nodes.map(async (node: Node) => {\n          if(node.isBusy()) await node.toFinish();\n          return callback(node);\n      });\n      // wait for all the promises to resolve\n      return Promise.all(promises);\n  }\n\n  public async registerServices(services: ServiceAddress[]) {\n      // register the services to all the nodes\n      return this.broadcast(\n          async (node: Node) => await node.registerServices(services)\n      );\n  }\n\n  public async spawnNodes(name: string = '', count: number = 1, metadata: any = {}) {\n      /* spawn new nodes */\n      if(name === '') name = 'node_' + this.name;\n      log('[nodeManager][spawnNodes] spawning nodes', name, count);\n      this.cluster.spawn(name, {\n          numberOfSpawns: count,\n          metadata: metadata\n      });\n  }\n\n  public async killNode(nodeId: string = '') {\n      // this function will get an idle node fom the pool\n      if(this.nodes.isEmpty())\n          return false\n      // get an idle node\n      let node = (nodeId === '')?\n          this.nodes.removeOne() :\n          this.nodes.remove(nodeId);\n      if(node === null || node === undefined)\n          throw new Error('Node sentenced to death could not be found');\n      // and exit it\n      await node.exit();\n  }\n\n  public async killNodes(nodesId: string[]=[]) {\n      /* kill nodes */\n      for(let nodeId of nodesId)\n          await this.killNode(nodeId);\n  }\n\n  public getIdleCount(){\n      // return the number of idle nodes\n    return this.nodes.getEnabledCount();\n  }\n\n  public getBusyCount(){\n      // return the number of busy nodes\n    return this.nodes.getDisabledCount();\n  }\n\n  public getNodes() {\n      // get all nodes\n      return this.nodes.toArray();\n  }\n\n  public nextNode() {\n      return this.nodes.next();\n  }\n\n  public getNodeCount() {\n    return this.nodes.size();\n  }\n\n  public getNode(nodeId: string) {\n      // get a node by its id\n      let node = this.nodes.get(nodeId);\n      if(node === null) throw new Error(`[node manager] (ERROR) selected node ${nodeId} not found`);\n      return node;\n  }\n\n  public getListeners() {\n      if(this.network === undefined) throw new Error('network is undefined');\n      return this.network.getRegisteredListeners();\n  }\n\n  public async numberOfNodesConnected(count: number) {\n      let timeout = 100000;\n      await await_interval(() => this.nodes.size() >= count, timeout)\n      .catch(() => { throw new Error(`timeout of ${timeout} seconds, not enough nodes connected`) });\n      return true;\n  }\n\n\n  public async exit() {\n      // close all the nodes\n      return this.broadcast(\n          async (node: Node) => await node.exit()\n      );\n  }\n\n  private async broadcast(callback: (node: Node) => any) {\n      // get all the nodes\n      let nodes = this.nodes.toArray();\n      // for each node, make a promise\n      let promises = nodes.map(\n          async (node: Node) => await callback(node)\n      );\n      // wait for all the promises to resolve\n      return Promise.all(promises);\n  }\n\n  private setIdle = (NodeId: string) => this.nodes.enable(NodeId);\n\n  private setBusy = (NodeId: string) => this.nodes.disable(NodeId);\n\n  /* synonims */\n  public addNode = this.spawnNodes\n  public removeNode = this.killNodes\n  public getNumberOfNodes = this.getNodeCount;\n\n}\n\nexport default NodeManager;\n","import Node from './Node.js';\nimport NodeManager from './NodeManager.js';\n\nexport default Node \n\nexport { NodeManager };\n","import { await_interval, Queue, log } from '../utils/index.js';\nimport type { Request } from './types/index.js';\n\nclass RequestQueue {\n    /* This class will keep track of all the requests that are made to the service,\n     * how long each request takes to be processed,\n     * how many requests are in the queue,\n     * when the requests are being processed, and\n     * request individually.\n     */\n\n    private queue: Queue<Request> = new Queue();\n    private process_request: Function;\n    private get_slave: Function;\n    private isRunning: boolean = false;\n    private interval: NodeJS.Timeout;\n    private heartbeat = 100; // Check every 100ms if the request is completed\n    private turnover_times: number[] = []; // Stores time taken for the last 500 requests\n    private MAX_TURNOVER_ENTRIES = 500; // Limit storage to last 500 requests\n\n    constructor({ process_request, get_slave }: { process_request: Function, get_slave: Function }) {\n        /*\n         * Set an interval to check if there are items in the queue.\n         * If there are, pop the first element and process it.\n         * If there are no elements, wait for the next element to be added.\n         */\n        // set functions\n        this.process_request = process_request;\n        this.get_slave = get_slave;\n        if (!this.process_request) throw new Error('Process request cannot be null');\n        if (!this.get_slave) throw new Error('Get slave cannot be null');\n        // run interval\n        this.interval = setInterval(async () => {\n            // do not run another function if the previous one is still running\n            if (this.isRunning) return;\n            // if there are no items in the queue\n            if (this.queue.size() === 0) { \n                this.isRunning = false;\n                return;\n            }\n            // start the request function\n            this.isRunning = true;\n            // get the first request from queue\n            let request = this.queue.pop();\n            if(request === false) throw new Error('Request is null... is the request queue empty?');\n            // get a slave to process the request\n            const slave = await this.get_slave(request.selector);\n            // process the request\n            let startTime = Date.now();\n            let endTime : number;\n            // set running as false\n            this.isRunning = false;\n            // process the request\n            this.process_request(slave, request).then(\n                (result: any) => { // record the time\n                    if(!request) throw new Error('Request is false... is the request queue empty?');\n                    endTime = Date.now();\n                    // add values to the request\n                    request.completed = true;\n                    request.result = result;\n                    // Track the time taken for this request\n                    const timeTaken = endTime - startTime;\n                    //log(`[RequestQueue] Request completed in ${timeTaken}ms`);\n                    this.turnover_times.push(timeTaken);\n                    // Keep only the last 500 entries\n                    if (this.turnover_times.length > this.MAX_TURNOVER_ENTRIES) \n                        this.turnover_times.shift(); // Remove the oldest entry\n                }\n            ).catch((err : any) => {\n                console.error('[RequestQueue] Request failed to complete');\n                console.error(err);\n                return err;\n            });\n        }, 100);\n    }\n\n    public addRequest(request: Request): Promise<any> {\n        // Add request to the queue and return a promise\n        // that will be resolved when the request is completed\n        return new Promise(async (resolve, reject) => {\n            this.queue.push(request);\n            // Wait until the request is completed, or 60 minutes\n            await await_interval(() => {\n                log(request);\n                return request.completed === true;\n            }, 60 * 60 * 1000, this.heartbeat)\n            .catch(err => {\n                console.error('[RequestQueue] Request failed to complete');\n                console.error(err);\n                reject(err)\n            });\n            // Resolve the promise with the result of the request\n            resolve(request.result);\n        });\n    }\n\n    public queueSize() : number {\n        return this.queue.size();\n    }\n\n    public getTurnoverRatio(): number {\n        if (this.turnover_times.length === 0) return 0;\n        const sum = this.turnover_times.reduce((acc, time) => acc + time, 0);\n        return sum / this.turnover_times.length;\n    }\n\n    public exit() {\n        this.queue.clear();\n        clearInterval(this.interval);\n\n    }\n}\n\nexport default RequestQueue;\n","import os from 'os';\nimport { log } from '../utils/index.js';\n\ninterface balancerConfig {\n    minSlaves?: number;\n    maxSlaves?: number;\n    queueScaleUpThreshold?: number;\n    queueScaleDownThreshold?: number;\n    maxIdleRateThreshold?: number;\n    minIdleRateThreshold?: number;\n    cpuThreshold?: number;\n    memThreshold?: number;\n    checkInterval?: number;\n    checkSlaves: (() => { idleCount: number | undefined, workingCount:number | undefined }) | undefined;\n    checkQueueSize: (() => number) | undefined;\n    addSlave: (() => void) | undefined;\n    removeSlave: (() => void) | undefined;\n}\n\nclass ProcessBalancer {\n    private prevQueueSize: number = 0;\n    private interval: NodeJS.Timeout | undefined;\n    private queueScaleUpThreshold: number;\n    private queueScaleDownThreshold: number;\n    private maxIdleRateThreshold: number;\n    private minIdleRateThreshold: number;\n    private cpuThreshold: number;\n    private memThreshold: number;\n    private checkInterval: number;\n    private checkQueueSize: (() => number) | undefined;\n    private checkSlaves: (() => { idleCount: number | undefined, workingCount:number | undefined }) | undefined;\n    private addSlave: (() => void) | undefined;\n    private removeSlave: (() => void) | undefined;\n\n    constructor(config: balancerConfig) {\n        // if there is at least 3 request in the queue, allow to scale up\n        this.queueScaleUpThreshold = config.queueScaleUpThreshold || 3;\n        // if there is at most one request on the queue, allow to scale down\n        this.queueScaleDownThreshold = config.queueScaleDownThreshold || 0;\n        // if we are using a lot of resources, don't scale up\n        this.cpuThreshold = config.cpuThreshold || 90;\n        this.memThreshold = config.memThreshold || 90;\n        // if 80 percent of all slaves are idle, don't allow to make more\n        this.maxIdleRateThreshold = config.maxIdleRateThreshold || 0.8\n        // if 10 percent of all slaves are idle, don't remove any\n        this.minIdleRateThreshold = config.minIdleRateThreshold || 0.1\n        // how often do we check\n        this.checkInterval = config.checkInterval || 500;\n        // function need to check\n        this.checkQueueSize = config.checkQueueSize;\n        this.checkSlaves = config.checkSlaves;\n        this.addSlave = config.addSlave;\n        this.removeSlave = config.removeSlave;\n        // check if we got all the need callbacks\n        this.checkRequiredFunctions();\n        // Initialize monitoring\n        this.interval = this.startMonitoring();\n    }\n\n    private getCpuUsage(): number {\n        let cpus = os.cpus();\n        let totalLoad = cpus.reduce((acc, cpu) => {\n            let total = Object.values(cpu.times).reduce((t, v) => t + v, 0);\n            return acc + (cpu.times.user / total) * 100;\n        }, 0);\n        return totalLoad / cpus.length;\n    }\n\n    private getMemoryUsage(): number {\n        return ((os.totalmem() - os.freemem()) / os.totalmem()) * 100;\n    }\n\n    private monitorSystem(): void {\n        if(this.checkQueueSize === undefined) throw Error('checkQueueSize is undefined');\n        if(this.checkSlaves === undefined) throw Error('checkSlaves is undefined');\n\n        this.checkRequiredFunctions();\n        const queueSize = this.checkQueueSize();\n        const { idleCount, workingCount } = this.checkSlaves();\n        if(idleCount === undefined || workingCount === undefined)\n            throw new Error('checkSlaves function returned idleCount or workingCount with value of undefined')\n        const idleRate = idleCount / workingCount + idleCount\n        const queueGrowth = queueSize - this.prevQueueSize;\n        this.prevQueueSize = queueSize;\n        const avgCpu = this.getCpuUsage();\n        const avgMem = this.getMemoryUsage();\n\n        /*\n        log(`[ProcessBalancer]\n            Queue Size: ${queueSize},\n            Growth: ${queueGrowth},\n            CPU: ${avgCpu.toFixed(2)}%,\n            MEM: ${avgMem.toFixed(2)}%,\n            Idle Slaves: ${idleCount},\n            Working Slaves: ${workingCount},\n            Total Slaves: ${idleCount + workingCount},\n            Idle Ratio: ${(idleCount / workingCount).toFixed(2)}`\n           );\n           */\n\n           if (\n               // if the queue size is passed a threshold: 3\n               queueSize > this.queueScaleUpThreshold &&\n               // and it is growing\n               queueGrowth > 0 &&\n               // and the average CPU and MEM usage is below 90%\n               avgCpu < this.cpuThreshold &&\n               avgMem < this.memThreshold &&\n               // and the ratio of idle slaves to working slaves is greater than than threshold\n               idleRate < this.maxIdleRateThreshold\n           ){\n               log('Scaling up, adding a node');\n               //@ts-ignore\n               this.addSlave();\n           }\n           if ( // if the queue size is less than or equal to the threshold\n               queueSize <= this.queueScaleDownThreshold &&\n               // if there is at least one\n               idleCount > 1 &&\n               // if the queue size is degreesing or not growing\n               queueGrowth <= 0 &&\n               // if the idle rate is low\n               idleRate > this.minIdleRateThreshold\n              ){\n                  log('Scaling down, removing a node');\n                  //@ts-ignore\n                  this.removeSlave();\n              }\n    }\n\n    private startMonitoring(): NodeJS.Timeout {\n        return setInterval(() => {\n            this.monitorSystem();\n        }, this.checkInterval);\n    }\n\n    private checkRequiredFunctions(): void {\n        if (this.checkQueueSize === undefined)\n            throw new Error('Missing required function checkQueueSize in config');\n        if (this.checkSlaves === undefined)\n            throw new Error('Missing required function checkSlaves in config');\n        if (this.addSlave === undefined)\n            throw new Error('Missing required function addSlave in config');\n        if (this.removeSlave === undefined)\n            throw new Error('Missing required function removeSlave in config');\n    }\n\n    public exit(): void {\n        // end monitoring\n        clearInterval(this.interval);\n    }\n}\n\nexport default ProcessBalancer;\n","import Network, { Listener } from '../network/index.js';\nimport { deserializeError } from 'serialize-error';\n\ntype Options = {\n    throwError?: boolean,\n    returnError?: boolean,\n    logError?: boolean\n}\n\n\nclass ServiceClient {\n    /* this class will be used to connect to a diffrent service,\n     * it will convert the class into a client handler for other services\n     * it will connect to the service and create methods\n     * for every listener that the service has. */\n    public name: string;\n    public network: Network;\n    public options: Options;\n    // this is use to select nodes\n    public selection: string[] = []; \n    private listeners: Listener[] = [];\n    // get the network from the connection\n    constructor(name: string, network: Network, options: Options = {}, selection?: [] ) {\n        this.name = name;\n        this.network = network;\n        if(options.throwError === undefined) options.throwError = true;\n        this.options = options;\n        this.selection = selection || [];\n        // get the conenction from the network\n        let connection = this.network.getService(name);\n        if(connection === null) throw new Error(`Service ${name} not found`);\n        // get the listneres from the target connection\n        this.listeners = connection.targetListeners;\n        // if we have a selection\n        if(this.selection.length === 0) {\n            // create method from listners which run the query on the connection\n            this.listeners.forEach((listener: Listener) => {\n                (this as any)[listener.event] = \n                    async (parameters: any) => await this.sendRequest(listener.event, { parameters });\n            });\n        }else{\n            // create method from listners which run the query on the connection\n            this.listeners.forEach((listener: Listener) => {\n                (this as any)[listener.event] = \n                    // if we have a selection we send a request to every node on the selection\n                    async (parameters: any) => {\n                    let results = await Promise.all(\n                        this.selection.map(\n                            async (nodeId: string) => await this.sendRequest(\n                                listener.event, { parameters, selection: nodeId }\n                            )\n                        )\n                    )\n                    // if we only have one node we return the result\n                    if(results.length === 1) return results[0];\n                    else return results;\n                }\n            });\n        }\n    }\n\n    private async sendRequest(event: string, data: any) {\n        // get the connection\n        let connection = this.network.getService(this.name);\n        // and send the data\n        if (connection === null) throw new Error(`Service ${this.name} not found`);\n        let response = await connection.send(event, data);\n        // check if we got an error and handle it\n        if (response.isError === true) \n            return this.handleErrors(response.error);\n        return response.result;\n    }\n\n\n    // We define a seperate method selecting \n    // a one or a group of nodes in a service\n    public async select(num?: number | 'all') {\n        // undefined selects all nodes\n        if(num === undefined) num = 1\n        if(num === 'all') num = 0\n        // send server to select a node\n        let selection = await this.sendRequest('_select', { parameters: num });\n        // check if we got an error and handle it\n        if(selection === null) return;\n        // set the selection\n        return new ServiceClient(this.name, this.network, this.options, selection);\n    }\n\n    public async exec(code: string) {\n        // execute albitrary code on the a node\n        if(this.selection.length === 0) {\n            return await this.sendRequest('_exec', { parameters: code.toString() });\n        } else {\n            // if we have selection we send a request to every node on the selection\n           let results = await Promise.all(\n                this.selection.map(\n                    async (nodeId: string) => await this.sendRequest(\n                        '_exec', { parameters: code.toString(), selection: nodeId }\n                    )\n                )\n            );\n            // if we only have one node we return the result\n            if(results.length === 1) return results[0];\n            else return results;\n        }\n    }\n\n\n    public async exec_master(code: string) {\n        // execute albitrary code on the master node\n        return await this.sendRequest('_exec_master', { parameters: code.toString() });\n    }\n\n    private handleErrors(error_obj: Error) {\n        // deserialize the error, handle according to the options\n        let error = deserializeError(error_obj);\n        if (this.options.throwError) throw error;\n        if (this.options.logError) console.error(error);\n        if (this.options.returnError) return error;\n        else return null;\n    }\n    \n}\n\nexport default ServiceClient;\n","type StashItem = any;\n\nclass Stash {\n    private store: Map<string, StashItem> = new Map();\n    private queue: Promise<void> = Promise.resolve();\n\n    /**\n     * Internal method to serialize and validate JSON-serializable object\n     */\n    private validateSerializable(value: StashItem): void {\n        // since we are using socket.io, there is no need\n        try {\n            JSON.stringify(value);\n        } catch (err) {\n            throw new Error(\"Value must be JSON-serializable.\");\n        }\n    }\n\n    /**\n     * Internal lock function to queue up tasks\n     */\n    private async withLock<T>(fn: () => Promise<T>): Promise<T> {\n        let release: () => void;\n        const next = new Promise<void>(resolve => (release = resolve));\n\n        const prev = this.queue;\n        this.queue = next;\n\n        await prev;\n        try {\n            return await fn();\n        } finally {\n            release!();\n        }\n    }\n\n    async set(key: string, value: StashItem): Promise<void> {\n        // if now key is pass assume a defualt key\n        if(value === undefined || value === null) {\n            value = key;\n            key = '_default';\n        }\n        //this.validateSerializable(value);\n        return this.withLock(async () => {\n            this.store.set(key, value);\n        });\n    }\n\n    async get<T = StashItem>(key: string): Promise<T | undefined> {\n        if(key === undefined || key === null || key === '')\n            key = '_default';\n        return this.withLock(async () => {\n            return this.store.get(key);\n        });\n    }\n\n    async delete(key: string): Promise<void> {\n        if(key === undefined || key === null || key === '')\n            key = '_default';\n        return this.withLock(async () => {\n            this.store.delete(key);\n        });\n    }\n\n    async clear(): Promise<void> {\n        return this.withLock(async () => {\n            this.store.clear();\n        });\n    }\n\n    async has(key: string): Promise<boolean> {\n        if(key === undefined || key === null || key === '')\n            key = '_default';\n        return this.withLock(async () => {\n            return this.store.has(key);\n        });\n    }\n\n    async keys(): Promise<string[]> {\n        return this.withLock(async () => {\n            return Array.from(this.store.keys());\n        });\n    }\n}\n\nexport default Stash;\n","import Network, { Listener, Connection } from '../network/index.js';\nimport Node, { NodeManager } from '../nodes/index.js';\nimport Cluster from '../cluster/index.js';\nimport { PeerDiscoveryClient } from '../app/peerDiscovery/index.js';\nimport RequestQueue from './RequestQueue.js';\nimport ProcessBalancer from './ProcessBalancer.js';\nimport ServiceClient from './ServiceClient.js';\nimport Stash from './Stash.js';\nimport { toListeners, log, getPort, isServerActive, execAsyncCode, await_interval } from '../utils/index.js';\nimport type { ServiceAddress, SlaveMethods, Request, Options } from './types/index.js';\nimport { serializeError } from 'serialize-error';\n\n// the paramer the service will take\ntype Parameters = {\n    // the name of the service\n    service_name: string,\n    // the address of the service will take\n    peerServicesAddresses?: ServiceAddress[],\n    // the adderess of the peer discovery service used to find the other services\n    peerDiscoveryAddress?: { host: string, port: number },\n    // the master callback that will be called by the master process\n    mastercallback?: (...args: any[]) => any,\n    // the slave callbacks that will be called by the slaves\n    slaveMethods?: SlaveMethods,\n    // the options that will be passed to the service\n    options?: Options\n};\n\nclass Service {\n    /* This will be the based class for the service which salvery will call to create proceses */\n    public name: string;\n    public host: string;\n    public port: number;\n    private nodes?: NodeManager;\n    private stash: Stash = new Stash();\n    private processBalancer?: ProcessBalancer | null = null;\n    private requestQueue: RequestQueue | null = null;\n    public nm_host: string;\n    public nm_port: number;\n    public number_of_nodes: number;\n    private masterCallback?: (...args: any[]) => any;\n    private slaveMethods: SlaveMethods;\n    private peerAddresses: ServiceAddress[];\n    private peerDiscoveryAddress?: { host: string, port: number };\n    private peerDiscovery?: PeerDiscoveryClient;\n    private cluster?: Cluster;\n    private network?: Network;\n    private options: Options;\n    private servicesConnected: boolean = false;\n\n    constructor(params: Parameters) {\n        this.name = params.service_name;\n        // the address of the service will take\n        this.host = params.options?.host || 'localhost';\n        this.port = params?.options?.port || 0;\n        // the host of the node manager\n        this.nm_host = params.options?.nm_host || 'localhost';\n        this.nm_port = params.options?.nm_port || 0;\n        // the call that will run the master process\n        this.masterCallback = params.mastercallback || undefined;\n        // the method that we will use ont he slave\n        this.slaveMethods = params.slaveMethods || {};\n        // other sevices that we conenct to\n        this.peerAddresses = params.peerServicesAddresses || [];\n        // the peer discovery service\n        this.peerDiscoveryAddress = params.peerDiscoveryAddress || undefined;\n        this.peerDiscovery = undefined;\n        // if both the peerAddresses and the peerDiscoveryServiceAddress are not defined,\n        // we will throw an error\n        if(this.peerAddresses === undefined && this.peerDiscoveryAddress === undefined)\n            throw new Error('Peer Addresses or Peer Discovery Service Address must be defined');\n        // the options that will be passed to the service\n        this.options = params.options || {};\n        // smallest number of processes need to run\n        // the master and a slave\n        if(this.options.number_of_nodes === undefined){\n            this.number_of_nodes = 1;\n            if(this.options.auto_scale === undefined)\n                this.options.auto_scale = true;\n        }else{\n            this.number_of_nodes = this.options.number_of_nodes;\n            if(this.options.auto_scale === undefined)\n                this.options.auto_scale = false\n        }\n    }\n\n    public async start() { // this will start the service\n        // let initlize the cluster so that we can start the service\n        this.cluster = new Cluster(this.options);\n       // create a new process for the master process\n        this.cluster.spawn('master_' + this.name, {\n            allowedToSpawn: true, // give the ability to spawn new processes\n            spawnOnlyFromPrimary: true // make sure that only one master process is created\n        });\n        // run the code for the master process\n        if(this.cluster.is('master_' + this.name)) {\n            // initialize the master process\n            await this.initialize_master();\n        }\n        // if the cluster is a slave we initialize the process\n        if(this.cluster.is('slave_' + this.name)) {\n            await this.initialize_slaves();\n        }\n    }\n\n    private async initialize_master() {\n        // initialize the master and all the services\n        // get the port for the service\n        if(this.port === 0) this.port = await getPort({host: this.host});\n        // if we have a peer discovery service we will try to connect to it\n        if(this.peerDiscoveryAddress !== undefined) await this.handle_peer_discovery();\n        log('peer addresses', this.peerAddresses);\n        // initialize the node manager\n        await this.initlize_node_manager();\n        // initialize the request queue\n        this.initialize_request_queue();\n        // initlieze the network and create a service\n        this.network = new Network({name: this.name + '_service_network'});\n        // list the listeners we have for the other services to request\n        let listeners = toListeners(this.slaveMethods).map(\n            // add out handle request function to the listener\n            l => ({ ...l, callback: this.handle_request(l, 'run') })\n        );\n        // add the _exec listner, we have to add it here as the listners in \n        // this.getServiceListeners strips the selector\n        let exec_listener : Listener = { event: '_exec', callback: ()=>{} };\n        listeners.push({ ...exec_listener, callback: this.handle_request(exec_listener, 'exec') });\n        // add the local service listener\n        listeners = listeners.concat(this.getServiceListeners());\n        // create the server\n        this.network.createServer(this.name, this.host, this.port, listeners);\n        // initilze the process balancer\n        this.initialize_process_balancer();\n        // remover self address from the peer addresses by name\n        this.peerAddresses = this.peerAddresses.filter((p: ServiceAddress) => p.name !== this.name);\n        // connect to the services\n        let connections = await this.network.connectAll(this.peerAddresses);\n        // create a service client for the services\n        let services = connections.map( (c: Connection) => {\n            let name = c.getTargetName();\n            if(name === undefined) throw new Error('Service name is undefined');\n            return new ServiceClient(name, this.network as Network, this.options);\n        }).reduce((acc: any, s: ServiceClient) => {\n            acc[s.name] = s;\n            return acc;\n        }, {})\n        // set service as connected\n        this.servicesConnected = true;\n        // run the callback for the master process\n        if(this.masterCallback !== undefined)\n            this.masterCallback({ ...services, slaves: this.nodes, master: this, self: this });\n    }\n\n    private async initialize_slaves() {\n        let node = new Node();\n        // TODO: Need to find a better way to pass the host and port\n        // to the slave process, so far I am only able to pass it through\n        // the metadata in the cluster\n        // get the nm_host and nm_port from the metadata\n        let metadata = process.env.metadata;\n        if(metadata === undefined)\n            throw new Error('could not get post and host of the node manager, metadata is undefined');\n        let { host, port } = JSON.parse(metadata)['metadata'];\n        // connect with the master process\n        await node.connectToMaster(host, port);\n        // add services to the node\n        await node.setServices(this.peerAddresses);\n        // read the methods to be used\n        node.addMethods(this.slaveMethods)\n        // run _startup method\n        await node._startup();\n    }\n\n    private async initlize_node_manager() {\n        /* the node manage will be used to conenct to and manage the nodes */\n        // if the slave methods is an empty object we will not make any nodes\n        if(Object.keys(this.slaveMethods).length === 0) return null;\n        // get the port for the node manager\n        if(this.nm_port === 0)\n            this.nm_port = await getPort({host: this.nm_host});\n        // make a node manager\n        this.nodes = new NodeManager({\n            name: this.name,\n            host: this.nm_host,\n            port: this.nm_port,\n            stash: this.stash, // set the stash\n        })\n        // spawn the nodes from the node Manager\n        await this.nodes.spawnNodes('slave_' + this.name, this.number_of_nodes, {\n            metadata: { host: this.nm_host, port: this.nm_port }\n        });\n        // register the services in the nodes\n        await this.nodes.registerServices(this.peerAddresses);\n        // get the nodes\n        return this.nodes;\n    }\n\n    private initialize_request_queue() {\n        /* this function will give the request queue all the values an callback it need tow work */\n        // if there are no nodes to make don't create a request queue\n        if(Object.keys(this.slaveMethods).length === 0) return null\n            // if node manager is not defined throw an error\n            if(this.nodes === undefined) throw new Error('Node Manager is not defined');\n            // create a new request queue\n            this.requestQueue = new RequestQueue({\n                // we pass the functions that the request queue will use\n                get_slave: this.nodes.getIdle.bind(this.nodes),\n                process_request:\n                    async (node: Node, request: Request) => await node[request.type](request.method, request.parameters)\n                \n            });\n    }\n\n    private initialize_process_balancer() {\n        /* this function will initialize the process balancer */\n        if(Object.keys(this.slaveMethods).length === 0) return null;\n        // if the auto scale is true we will create a process balancer\n        if(this.options.auto_scale === true){\n            this.processBalancer = new ProcessBalancer({\n                // pass the functions need for the balancer to know the hwo to balance\n                checkQueueSize: this.requestQueue?.queueSize.bind(this.requestQueue),\n                checkSlaves: () => ({ idleCount: this.nodes?.getIdleCount(), workingCount: this.nodes?.getBusyCount() }),\n                addSlave: () => this.nodes?.spawnNodes( 'slave_' + this.name, 1, { metadata: { host: this.nm_host, port: this.nm_port } }),\n                removeSlave: () => this.nodes?.killNode()\n            });\n        }\n    }\n\n\n    private getServiceListeners() {\n        // let add the listeners which we this service will respond\n        // lets ignore the selector field\n        let listeners = [{\n            // get number of nodes\n            event: '_get_nodes_count',\n            callback: () => ({ result: this.nodes?.getNodeCount() })\n        },{\n            event: '_get_nodes',\n            callback: () => this.nodes?.getNodes().map((n: Node) => ({ status: n.status, id: n.id }))\n        },{\n            event: '_get_idle_nodes', // wee need to filter this array of objects\n            callback: () => ({ result: this.nodes?.getIdleNodes() })\n        },{\n            event: '_get_busy_nodes', // this one too\n            callback: () =>({ result: this.nodes?.getBusyNodes() })\n        },{\n            event: '_number_of_nodes_connected',\n            params: ['node_num'],\n            callback: async (node_num: number) => await this.nodes?.numberOfNodesConnected(node_num)\n        },{ // select individual nodes, or groups of nodes\n            event: '_select',\n            params: ['node_num'],\n            callback: async (node_num: number) => {\n                if(this.nodes === undefined) throw new Error('Nodes are undefined');\n                // get the idle nodes\n                let count = this.nodes?.getNodeCount();\n                if(count === undefined) return { isError: true, error: serializeError(new Error('Nodes are undefined')) }\n                // if the number of nodes is greater than the number of nodes we have\n                if(node_num > count) return { isError: true, error: serializeError(new Error('Not enough nodes')) }\n                if(node_num === 0) node_num = count;\n                // select the nodes\n                let selected_nodes = [];\n                for(let i = 0; i < node_num; i++){\n                    let node = this.nodes?.nextNode();\n                    if(node === null) throw new Error('could not get node');\n                    selected_nodes.push(node.id);\n                }\n                // return the selected nodes\n                return { result: selected_nodes }\n            }\n        },{ // spawn or kill a node\n            event: '_add_node',\n            params: ['number_of_nodes'],\n            callback: (number_of_nodes: number) =>\n            ({ result: this.nodes?.spawnNodes(\n                'slave_' + this.name,\n                number_of_nodes,\n                { metadata: { host: this.nm_host, port: this.nm_port } }\n            ) })\n        },{ // kill a node\n            event: '_kill_node',\n            params: ['node_id'],\n            callback: async(node_ids: string[] | string | undefined | number) => {\n                let res;\n                if(node_ids === undefined){\n                    res = await this.nodes?.killNode();\n                }else if(typeof node_ids === 'string'){\n                    res = await this.nodes?.killNode(node_ids);\n                }else if(typeof node_ids === 'number'){\n                    for(let i = 0; i < node_ids; i++) await this.nodes?.killNode();\n                }else if(node_ids.length === 0){\n                    res = await this.nodes?.killNode();\n                }else if(node_ids.length >= 1){\n                    res = await this.nodes?.killNodes(node_ids);\n                }else {\n                    return { isError: true, error: serializeError(new Error('Invalid node id')) }\n                }\n                return ({result: res});\n            }\n        },{ // exit the service\n            event: '_queue_size',\n            callback: () => ({ result: this.requestQueue?.queueSize() })\n        },{\n            event: '_turn_over_ratio',\n            callback: () => ({ result: this.requestQueue?.getTurnoverRatio() })\n        },{\n            event: '_exec_master',\n            params: ['code_string'],\n            callback: async (code_string: any) => {\n                // check if the code_string is a string\n                if(typeof code_string !== 'string')\n                    return { isError: true, error: serializeError(new Error('Code string is not a string')) }\n                // await until service is connected\n                await await_interval(() => this.servicesConnected, 10000).catch(() => {\n                    throw new Error(`[Service] Could not connect to the services`);\n                })\n                let service = this.getServices();\n                let parameter = { ...service, master: this, self: this };\n                try {\n                    // run the albitrary code\n                    let result = await execAsyncCode(code_string, parameter);\n                    return { result: result }\n                } catch(e)  {\n                    return { isError: true, error: serializeError(e) }\n                }\n            }\n        },{\n            event: 'new_service',\n            params: ['service_address'],\n            callback: async (service_address: ServiceAddress) => {\n                if(this.network === undefined) throw new Error('Network is not defined');\n                await this.network?.connect(service_address);\n            }\n        },{\n            event: 'exit',\n            callback: () => ({ result: this.exit() })\n        }];\n        // get only the paramters, diregar the rest\n        return listeners.map(l => {\n            return { ...l, callback: ({ parameters }: any) => l.callback(parameters) }\n        });\n    }\n\n    private handle_request(l: Listener, type: 'run' | 'exec'): Function {\n        /* this function will take a listener triggered by another a request\n         * it will set the request in the  request queue, and return a promise\n         * which resolves once the request is processed.\n         * the queue will processs the request when it finds an idle node\n         * and the node returns the result. */\n        return async (data: any) => {\n            if(this.slaveMethods === undefined) throw new Error('Slave Methods are not defined');\n            if(this.requestQueue === null)\n                throw new Error('Request Queue is not defined');\n            let promise = this.requestQueue.addRequest({\n                method: l.event,\n                type: type,\n                parameters: data.parameters,\n                selector: data.selection,\n                completed: false,\n                result: null\n            });\n            // wait until the request is processed\n            let result = await promise;\n            if(result.isError === true) // if there is an error serialize it\n                result.error = serializeError(result.error);\n            return result;\n        }\n    }\n\n    private async handle_peer_discovery() {\n        if(this.peerDiscoveryAddress === undefined) throw new Error('Peer Discovery Address is not defined');\n        if(this.cluster === undefined) throw new Error('Cluster is not defined');\n        // check if the peer discovery service is active\n        log(`[${this.name}] > Service > Checking if Peer Discovery Service is active`);\n        log(`[${this.name}] > Service > Peer Discovery Address: ${this.peerDiscoveryAddress.host}:${this.peerDiscoveryAddress.port}`);\n        if(await isServerActive(this.peerDiscoveryAddress) === false)\n            throw new Error('Peer Discovery Service is not active');\n        // if it is active we will register to it\n        this.peerDiscovery = new PeerDiscoveryClient(this.peerDiscoveryAddress);\n        await this.peerDiscovery.connect();\n        // register the service to the peer discovery service\n        this.peerDiscovery.register({ name: this.name, host: this.host, port: this.port });\n        // get the services that we will connect to\n        this.peerAddresses = await this.peerDiscovery.getServices();\n    }\n\n    private getServices(): { [serviceName: string]: ServiceClient } {\n        // get the service from the network\n        if(this.network === undefined) throw new Error('Network is not defined');\n        let services = this.network.getServices()\n        return services.map( (c: Connection) => {\n            let name = c.getTargetName();\n            if(name === undefined) throw new Error('Service name is undefined');\n            return new ServiceClient(name, this.network as Network, this.options);\n        }).reduce((acc: any, s: ServiceClient) => {\n            acc[s.name] = s;\n            return acc;\n        }, {})\n    }\n\n    public exit(){\n        //log(`[${this.name}] will exit in 1 seconds`);\n        setTimeout(() => {\n            // first we close the ProcessBalancer if we have one\n            if(this.processBalancer) this.processBalancer.exit();\n            // request queue will be closed\n            if(this.requestQueue) this.requestQueue.exit();\n            // if peer discovery is defined we will close it\n            if(this.peerDiscovery) this.peerDiscovery.exit();\n            // then we close the nodes Manager\n            if(this.nodes) this.nodes.exit();\n            // then we close the connections we have,\n            if(this.network) this.network.close();\n            // lastly we close ourselves, how sad\n            process.exit(0);\n        }, 1000);\n        return true\n    }\n\n    public set = async (key: any, value: any = null) =>\n        await this.stash.set(key, value);\n\n    public get = async (key: string = '') =>\n        await this.stash.get(key);\n}\n\n\n\nexport default Service;\n","import Service from './Service.js';\nimport ServiceClient from './ServiceClient.js';\nimport RequestQueue from './RequestQueue.js';\nimport ProcessBalancer from './ProcessBalancer.js';\nimport Stash from './Stash.js';\nimport type { Options, ServiceAddress, SlaveMethods } from './types/index.js';\n\nexport default Service;\n\nexport { Options, ServiceAddress, RequestQueue,\n    SlaveMethods, ServiceClient, ProcessBalancer,\n    Stash };\n","import type { SlaveMethods, Options as ServiceOptions } from '../service/types/index.js';\n\ntype callableFunction = (...args: any[]) => any;\n\nfunction isSlaveMethods(obj: any): obj is SlaveMethods {\n    if(obj === null || obj === undefined) return false;\n  return (\n    obj &&\n    typeof obj === 'object' &&\n    Object.values(obj).some(value => typeof value === 'function')\n  );\n}\n\nfunction isServiceOptions(obj: any): obj is ServiceOptions {\n    if(obj === null || obj === undefined) return false;\n    return (\n        obj &&\n            typeof obj === 'object' &&\n            Object.values(obj).every(value => typeof value !== 'function')\n    );\n}\n\nfunction isMasterCallback(value: any): value is Function | callableFunction {\n    if(value === null || value === undefined) return false;\n    return typeof value === 'function';\n}\n\nexport { isSlaveMethods, isServiceOptions, isMasterCallback };\n","import PeerDiscoveryServer from './peerDiscovery/index.js';\nimport makeProxyObject from './makeProxyObject.js';\nimport Service, { SlaveMethods, Options as ServiceOptions } from '../service/index.js';\nimport { isSlaveMethods, isMasterCallback } from './typeGuards.js';\n//import type { \n\ntype CallableFunction = (...args: any[]) => any;\n\ntype MasterCallback = Function | CallableFunction;\n\ntype EntryOptions = {\n    host: string;\n    port: number;\n}\n\nconst entry = (entryOptions: EntryOptions) => {\n    // this function is use to set up the options for the servies\n    let options = entryOptions;\n    // make a proxy object will take of xreating each service\n    let proxyObject = makeProxyObject(handleProxyCall(options));\n    // make the peer discovery server\n    let peerDiscoveryServer = new PeerDiscoveryServer({\n        host: options.host,\n        port: options.port,\n    });\n    peerDiscoveryServer.start();\n    // return the proxy object\n    return proxyObject; // <--- the proxy obj will return itself in perpituity\n}\n\n\nconst handleProxyCall = (globalOptions: EntryOptions) => (\n    // this are all of the possible input to service now the question is who to know \n    // which one wa passed\n    method: string,\n    param1: MasterCallback | SlaveMethods,\n    param2?: SlaveMethods | ServiceOptions, \n    param3?: ServiceOptions) => {\n        // first we check which function where passed\n        const { mastercallback, slaveMethods, options } = paramertesDiscermination(param1, param2, param3);\n        if(mastercallback === undefined) throw new Error('Master callback is undefined');\n        // get the service name and the functions\n        const service_name = method;\n        // get the port and the host\n        const port = globalOptions.port;\n        const host = globalOptions.host;\n        // make a new service\n        let service = new Service({\n            service_name,\n            peerDiscoveryAddress: { host, port },\n            mastercallback: mastercallback as CallableFunction,\n            slaveMethods,\n            options,\n        })\n        service.start()\n    }\n\n\nconst paramertesDiscermination = (param1: MasterCallback | SlaveMethods, param2?: SlaveMethods | ServiceOptions, param3?: ServiceOptions) => {\n    let mastercallback, slaveMethods, options;\n    // check if the first paramet is either a MasterCallback or SlaveMethods\n    if( isMasterCallback(param1) ) {\n        mastercallback = param1;\n        // check what the second paramter is\n        if( isSlaveMethods(param2) ) {\n            slaveMethods = param2;\n            options = param3 || {};\n        }\n    } else if( isSlaveMethods(param1) ) {\n        mastercallback = () => {};\n        slaveMethods = param1;\n        // check what the second paramter is\n        options = param2 || {};\n    } else { \n        throw new Error('Invalid first parameter. Must be either a funcition or an object');\n    }\n    return { \n        mastercallback,\n        slaveMethods,\n        options\n    }\n}\n\n\n\n\nexport default  entry;\n","import * as esprima from 'esprima';\n\ntype ParsedFunction = {\n    outer_function: Function\n    inner_functions: { name: string; fn: Function }[];\n};\n\nfunction extractFunctions(code: string): ParsedFunction {\n    const ast = esprima.parseScript(code, { range: true });\n    let outer = '';\n    const inner: { name: string; fn: string }[] = [];\n\nfor (const node of ast.body) {\n    if (node.type === 'FunctionDeclaration' && node.id?.name === 'hello') {\n        // Get outer function source code\n        const [start, end] = node.range!;\n        const outerSource = code.slice(start, end);\n\n        // Filter out inner functions from the body\n        const innerRanges: [number, number][] = [];\n\n        for (const stmt of node.body.body) {\n            if (stmt.type === 'FunctionDeclaration') {\n                const innerCode = code.slice(stmt.range![0], stmt.range![1]);\n                inner.push({ name: stmt.id!.name, fn: innerCode });\n                innerRanges.push([stmt.range![0], stmt.range![1]]);\n            }\n\n            // Variable declarations like: let fn = function(...) { ... }\n            if (\n                stmt.type === 'VariableDeclaration'\n            ) {\n                for (const decl of stmt.declarations) {\n                    if (\n                        decl.init &&\n                        (decl.init.type === 'FunctionExpression' ||\n                         decl.init.type === 'ArrowFunctionExpression')\n                    ) {\n                        const fnName = (decl.id as any).name;\n                        const fnCode = code.slice(stmt.range![0], stmt.range![1]);\n\n                        // Convert to \"function name(args) { ... }\" format\n                        const args = decl.init.params.map((p) => code.slice(p.range![0], p.range![1])).join(', ');\n                        const bodyCode = code.slice(decl.init.body.range![0], decl.init.body.range![1]);\n                        const formattedFn = `function ${fnName}(${args}) ${bodyCode}`;\n\n                        inner.push({ name: fnName, fn: formattedFn });\n                        innerRanges.push([stmt.range![0], stmt.range![1]]);\n                    }\n                }\n            }\n        }\n\n        // Remove inner function code from outer function body\n        let cleanedBody = code.slice(node.body.range![0] + 1, node.body.range![1] - 1);\n        for (const [start, end] of innerRanges) {\n            const innerCode = code.slice(start, end);\n            cleanedBody = cleanedBody.replace(innerCode, '');\n        }\n\n        outer = `${code.slice(node.range![0], node.body.range![0] + 1)}${cleanedBody}\\n}`;\n}\n}\n    // create the functions objects\n    let outer_function = new Function(outer);\n    let inner_functions = inner.map((fn) => ({ name: fn.name, fn: new Function(fn.fn) }));\n    // return\n    return { outer_function, inner_functions };\n}\n\n\n\nexport default extractFunctions;\n","import entrypoint from './entry.js'\nimport { isSlaveMethods, isServiceOptions, isMasterCallback } from './typeGuards.js'\nimport makeProxyObject from './makeProxyObject.js'\nimport extractFunctions from './extractFunctions.js'\nimport PeerDiscoverer from './peerDiscovery/index.js'\nimport type { Options } from './types/index.js'\n\n\nexport default entrypoint;\n\nexport { Options, PeerDiscoverer, makeProxyObject, extractFunctions, isSlaveMethods, isServiceOptions, isMasterCallback }\n\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,oBAAmB;AAKnB,IAAM,aAAN,MAAiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAyCb,YAAY;AAAA,IAAE;AAAA,IAAQ;AAAA,IAAM;AAAA,IAAM;AAAA,IAAI;AAAA,IAAM;AAAA,IAAW;AAAA,IAC3C;AAAA,IAAW;AAAA,IAAc;AAAA,EAAe,GAKjD;AAvCH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAQ;AACR,wBAAQ,cAAqB;AAE7B;AAAA,wBAAO;AACP,wBAAO;AACP,wBAAO,aAAwB,CAAC;AAChC,wBAAO;AACP,wBAAO;AACP,wBAAO;AAEP;AAAA,wBAAO;AAEP;AAAA,wBAAO;AACP,wBAAO;AACP,wBAAO;AACP,wBAAO;AACP,wBAAO,mBAA8B,CAAC;AACtC,wBAAO;AACP,wBAAO;AAEP;AAAA,wBAAQ;AACR,wBAAO;AACP,wBAAO;AA6OP,wBAAO,QAAO,KAAK;AA1Nf,SAAK,oBAAoB,cAAc,MAAM;AAAA,IAAC;AAC9C,SAAK,uBAAuB,iBAAiB,MAAM;AAAA,IAAC;AACpD,SAAK,yBAAyB,mBAAmB,MAAM;AAAA,IAAC;AAExD,QAAG,UAAW,MAAK,YAAY;AAE/B,QAAI,UAAU,MAAM;AAChB,WAAK,OAAO;AACZ,WAAK,OAAO;AACZ,WAAK,aAAa;AAElB,WAAK,SAAS;AAEd,WAAK,WAAW,OAAO,UAAU,KAAK;AAGtC,WAAK,cAAc;AAAA,IAEvB,WAAW,QAAQ,QAAQ,IAAI;AAC3B,WAAK,OAAO;AACZ,WAAK,aAAa;AAElB,WAAK,KAAK;AACV,WAAK,aAAS,kBAAG,QAAQ,IAAI,IAAI,IAAI,IAAI;AAAA,QACrC,MAAM,EAAE,GAAG;AAAA,QACX,SAAS,WAAW,MAAO;AAAA;AAAA,MAC/B,CAAC;AAED,WAAK,cAAc;AAAA,IACvB;AACI,YAAM,IAAI,MAAM,oEAAoE;AAExF,SAAK,WAAW,KAAK,OAAO;AAE5B,SAAK,oBAAoB;AAAA,EAC7B;AAAA,EAEQ,sBAA4B;AAGhC,SAAK,UAAU,QAAS,OAAK;AACzB,WAAK,OAAO,mBAAmB,EAAE,KAAK;AACtC,WAAK,OAAO,GAAG,EAAE,OAAO,KAAK,QAAQ,EAAE,OAAO,OAAO,eAAmB;AAEpE,eAAO,MAAM,EAAE,SAAS,UAAU;AAAA,MACtC,CAAC,CAAC;AAAA,IACN,CAAC;AAED,SAAK,OAAO,GAAG,cAAc,KAAK,QAAQ,cAAc,MAAM,KAAK,aAAa,CAAC,CAAC;AAElF,SAAK,OAAO,GAAG,kBAAkB,KAAK,QAAQ,kBAAkB,CAAC,cAAwB;AAErF,WAAK,kBACD,UAAU,IAAI,YAAU,EAAE,OAAO,UAAU,MAAM;AAAA,MAAC,EAAE,EAAE;AAC1D,WAAK,uBAAuB,KAAK,eAAe;AAChD,aAAO;AAAA,IACX,CAAC,CAAC;AAEF,SAAK,OAAO,GAAG,SAAS,KAAK,QAAQ,SAAS,MAAM,KAAK,IAAI,CAAC;AAE9D,SAAK,OAAO,GAAG,OAAO,MAAM,KAAK,EAAE;AAEnC,SAAK,OAAO,GAAG,WAAW,YAAY;AAGlC,WAAK,aAAa,MAAM,KAAK,gBAAgB;AAC7C,WAAK,kBAAkB,MAAM,KAAK,qBAAqB;AAEvD,WAAK,cAAc;AACnB,WAAK,kBAAkB,IAAI;AAAA,IAC/B,CAAC;AAED,SAAK,OAAO,GAAG,aAAa,OAAO,YAAoB;AAEnD,WAAK,aAAa,MAAM,KAAK,gBAAgB;AAC7C,WAAK,kBAAkB,MAAM,KAAK,qBAAqB;AACvD,WAAK,cAAc;AACnB,WAAK,kBAAkB,IAAI;AAAA,IAC/B,CAAC;AAED,SAAK,OAAO,GAAG,aAAa,MAAM;AAE9B,WAAK,cAAc;AACnB,WAAK,qBAAqB,IAAI;AAAA,IAClC,CAAC;AAAA,EACL;AAAA,EAEA,MAAa,YAA8B;AACvC,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACpC,UAAI;AACJ,UAAI;AAEJ,iBAAW,YAAY,MAAM;AACzB,YAAG,KAAK,aAAa;AACjB,wBAAc,QAAQ;AACtB,uBAAa,OAAO;AACpB,kBAAQ,IAAI;AAAA,QAChB;AAAA,MACJ,GAAG,GAAG;AAEN,gBAAU,WAAW,MAAM;AACvB,sBAAc,QAAQ;AACtB,eAAO,KAAK;AAAA,MAChB,GAAG,MAAO,EAAG;AAAA,IACjB,CAAC;AAAA,EACL;AAAA,EAGO,UAAS;AACZ,WAAO,KAAK;AAAA,EAChB;AAAA,EAEO,GAAG,OAAe,UAA0B;AAC/C,SAAK,OAAO,GAAG,OAAO,QAAQ;AAAA,EAClC;AAAA,EAEO,KAAK,OAAe,MAAiB;AACxC,SAAK,OAAO,KAAK,OAAO,IAAI;AAAA,EAChC;AAAA,EAEO,UAA8B;AACjC,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA,EAGO,QAA4B;AAC/B,WAAO,KAAK;AAAA,EAChB;AAAA,EAEO,gBAAoC;AACvC,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA,EAGO,cAAkC;AACrC,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,MAAa,aAAa,WAAsC;AAE5D,cAAU,QAAS,OAAK;AACpB,WAAK,UAAU,KAAK,CAAC;AAErB,WAAK,OAAO,mBAAmB,EAAE,KAAK;AAEtC,WAAK,OAAO,GAAG,EAAE,OAAO,KAAK,QAAQ,EAAE,OAAO,OAAO,eAAmB;AAEpE,eAAO,MAAM,EAAE,SAAS,UAAU;AAAA,MACtC,CAAC,CAAC;AAAA,IACN,CAAC;AAED,QAAG,KAAK,SAAS,UAAS;AAEtB,YAAM,KAAK,MAAM,kBAAkB,UAAU,IAAI,cAAY,SAAS,KAAK,CAAC;AAAA,IAEhF;AAAA,EACJ;AAAA,EAEO,aAAa,WAA6B;AAE7C,UAAM,WAAW,IAAI,IAAI,KAAK,UAAU,IAAI,OAAK,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC;AAE9D,cAAU,QAAS,OAAK,SAAS,IAAI,EAAE,OAAO,CAAC,CAAE;AAEjD,SAAK,YAAY,MAAM,KAAK,SAAS,OAAO,CAAC;AAE7C,SAAK,aAAa,KAAK,SAAS;AAAA,EACpC;AAAA,EAEO,qBAAiC;AACpC,WAAO,KAAK;AAAA,EAChB;AAAA,EAEO,eAAe,UAA0B;AAC5C,SAAK,yBAAyB;AAAA,EAClC;AAAA,EAEO,UAAU,UAA0B;AACvC,SAAK,oBAAoB;AAAA,EAC7B;AAAA,EAEO,aAAa,UAA0B;AAC1C,SAAK,uBAAuB;AAAA,EAChC;AAAA,EAEQ,uBAA4C;AAEhD,WAAO,KAAK,MAAM,YAAY;AAAA,EAClC;AAAA,EAEQ,kBAAmC;AAEvC,WAAO,KAAK,MAAM,OAAO;AAAA,EAC7B;AAAA;AAAA,EAGO,MAAM,OAAe,MAA0B;AAElD,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AAEpC,UAAI,UAAU,WAAY,MAAM;AAAE,eAAO,SAAS;AAAA,MAAE,GAAG,MAAO,EAAE;AAEhE,UAAI,aAAa,EAAE,KAAK;AACxB,UAAI,KAAK,cAAc,OAAO,mBAAmB,EAAG,MAAK,aAAa;AAEtE,WAAK,OAAO,KAAK,OAAO,EAAC,MAAM,WAAsB,CAAC;AACtD,WAAK,OAAO,GAAG,QAAQ,IAAI,UAAU,aAAa,CAAC,aAAkB;AAGjE,qBAAa,OAAO;AAEpB,aAAK,OAAO,mBAAmB,QAAQ,IAAI,UAAU,WAAW;AAEhE,gBAAQ,QAAQ;AAAA,MACpB,CAAC;AAAA,IACL,CAAC;AAAA,EACL;AAAA,EAIQ,QAAQ,OAAe,UAAoB;AAE/C,WAAO,OAAO,eAAoB;AAC9B,UAAI,OAAO,WAAW;AACtB,UAAI,aAAa,WAAW;AAC5B,UAAI,WAAW,MAAM,SAAS,IAAI;AAClC,WAAK,OAAO,KAAK,QAAQ,IAAI,UAAU,aAAa,QAAQ;AAAA,IAChE;AAAA,EACJ;AAAA,EAEO,eAAsB;AACzB,QAAG,KAAK,SAAS;AACb,aAAO,KAAK;AAAA,aACR,KAAK,SAAS;AAClB,aAAO,KAAK,OAAO;AAAA;AAEnB,YAAM,IAAI,MAAM,gCAAgC;AAAA,EACxD;AAAA,EAEO,QAAc;AACjB,SAAK,OAAO,WAAW;AAAA,EAC3B;AAEJ;AAEA,IAAO,qBAAQ;;;AC3Sf,IAAM,QAAN,MAAe;AAAA,EAGX,YAAa,QAAa,CAAC,GAAI;AAF/B,wBAAQ,SAAa,CAAC;AAiGtB;AAAA,iCAAQ,MAAM,KAAK,QAAQ,CAAC;AAG5B;AAAA,+BAAO,KAAK;AACZ,gCAAO,KAAK;AACZ,iCAAQ,KAAK;AACb,mCAAU,KAAK;AACf,iCAAQ,KAAK;AACb,+BAAM,KAAK;AAtGP,QAAG,MAAM,SAAS;AACd,WAAK,QAAQ;AAAA;AAEb,WAAK,QAAQ,CAAC;AAAA,EACtB;AAAA,EAEA,QAAQ,MAAS;AAEb,SAAK,MAAM,KAAK,IAAI;AACpB,WAAO;AAAA,EACX;AAAA,EAEA,UAAqB;AAEjB,QAAG,KAAK,MAAM,SAAS,GAAG;AACtB,YAAM,OAAO,KAAK,MAAM,MAAM;AAC9B,UAAG,SAAS,OAAW,QAAO;AAC9B,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX;AAAA,EAEA,OAAkB;AAEd,QAAG,KAAK,MAAM,SAAS,GAAG;AACtB,YAAM,OAAO,KAAK,MAAM,MAAM;AAC9B,UAAG,MAAM;AACL,aAAK,MAAM,KAAK,IAAI;AACpB,eAAO;AAAA,MACX;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA;AAAA,EAGA,SAAU,OAA2B;AACjC,QAAI,QAAQ,MAAM,QAAQ,KAAK,MAAM,QAAQ;AACzC,aAAO,KAAK,MAAM,OAAO,OAAO,CAAC,EAAE,CAAC;AAAA,IACxC,OAAM;AACF,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EAEA,QAAQ,MAAkB;AACtB,WAAO,KAAK,MAAM,QAAQ,IAAI;AAAA,EAClC;AAAA,EAEA,OAAO,MAAqB;AACxB,UAAM,QAAQ,KAAK,MAAM,QAAQ,IAAI;AACrC,QAAI,QAAQ,IAAI;AACZ,aAAO,KAAK,MAAM,OAAO,OAAO,CAAC,EAAE,CAAC;AAAA,IACxC,OAAM;AACF,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EAEA,OAAkB;AACd,WAAO,KAAK,MAAM,CAAC;AAAA,EACvB;AAAA,EAEA,aAAmB;AACf,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA,EAGA,UAAgB;AACZ,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA,EAGA,WAAoB;AAChB,QAAI,MAA4B,CAAC;AACjC,SAAK,MAAM,QAAS,CAAC,MAAM,UAAU;AACjC,UAAI,KAAK,IAAI;AAAA,IACjB,CAAC;AACD,WAAO;AAAA,EACX;AAAA;AAAA,EAGA,OAAgB;AACZ,WAAO,KAAK,MAAM;AAAA,EACtB;AAAA;AAAA,EAGA,SAAkB;AACd,WAAO,KAAK,MAAM;AAAA,EACtB;AAAA;AAAA,EAGA,UAAoB;AAChB,WAAO,KAAK,MAAM,WAAW;AAAA,EACjC;AAYJ;AAEA,IAAO,gBAAQ;;;AC3Gf,IAAM,OAAN,MAAc;AAAA,EAUV,cAAc;AAJd;AAAA;AAAA;AAAA;AAAA,wBAAQ;AACR,wBAAQ;AACR,wBAAQ;AAuOR;AAAA,gCAAO,KAAK;AACZ,+BAAM,KAAK;AACX,iCAAQ,KAAK;AACb,mCAAU,KAAK;AACf,gCAAO,KAAK;AACZ,iCAAQ,KAAK;AACb,oCAAW,KAAK;AAChB,sCAAa,KAAK;AA3Od,SAAK,UAAU,IAAI,cAAM;AACzB,SAAK,WAAW,CAAC;AACjB,SAAK,QAAQ,CAAC;AAAA,EAClB;AAAA,EAEA,IAAK,IAAsB;AACvB,WAAO,KAAK,MAAM,EAAE,IAAI,OAAO;AAAA,EACnC;AAAA,EAEA,IAAK,IAAY,MAAmB;AAEhC,QAAI,KAAK,IAAI,EAAE,EAAG,MAAK,OAAO,EAAE;AAEhC,SAAK,QAAQ,QAAQ,EAAE;AAEvB,SAAK,MAAM,EAAE,IAAI;AAEjB,WAAO;AAAA,EACX;AAAA,EAEA,QAAQ,IAAqB;AACzB,QAAI,CAAC,KAAK,IAAI,EAAE,EAAI,QAAO;AAE3B,QAAI,KAAK,SAAS,QAAQ,EAAE,MAAM,GAAK,QAAO;AAE9C,QAAI,KAAK,QAAQ,QAAQ,EAAE,MAAM,IAAI;AACjC,WAAK,QAAQ,OAAO,EAAE;AAEtB,WAAK,SAAS,KAAK,EAAE;AACrB,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX;AAAA,EAEA,aAAa,IAAY,iBAA+C;AAEpE,QAAI,CAAC,KAAK,IAAI,EAAE,EAAI;AAEpB,QAAI,OAAO;AACX,QAAI,YAAkB;AACtB,QAAG,OAAO,oBAAoB;AAC1B,aAAO;AAAA,aACH,OAAO,oBAAoB;AAC/B,kBAAY;AAAA,QACX,OAAM,IAAI,MAAM,gDAAgD;AAGrE,QAAI,KAAK,QAAQ,QAAQ,EAAE,MAAM,GAAK,MAAK,QAAQ,EAAE;AAErD,QAAI,KAAK,SAAS,QAAQ,EAAE,MAAM,GAAK,OAAM,IAAI,MAAM,gCAAgC;AAEvF,QAAG,KAAM,YAAW,MAAM,KAAK,OAAO,EAAE,GAAG,IAAI;AAE/C,QAAG,WAAU;AACT,UAAI,WAAW,YAAY,MAAM;AAC7B,YAAG,UAAU,GAAE;AACX,wBAAc,QAAQ;AACtB,eAAK,OAAO,EAAE;AAAA,QAClB;AAAA,MACJ,GAAG,GAAG;AAAA,IACV;AAAA,EACJ;AAAA,EAGA,OAAO,IAAsB;AAEzB,QAAI,CAAC,KAAK,IAAI,EAAE,EAAI,QAAO;AAE3B,QAAI,KAAK,QAAQ,QAAQ,EAAE,MAAM,GAAK,QAAO;AAE7C,QAAI,KAAK,SAAS,QAAQ,EAAE,MAAM,IAAI;AAElC,WAAK,WAAW,KAAK,SAAS,OAAQ,OAAK,MAAM,EAAG;AAEpD,WAAK,QAAQ,QAAQ,EAAE;AACvB,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX;AAAA,EAEA,gBAAmC;AAE/B,QAAI,KAAK,SAAS,WAAW,EAAI,QAAO;AAExC,QAAI,KAAK,KAAK,SAAS,CAAC;AAExB,SAAK,OAAO,EAAE;AAEd,WAAO;AAAA,EACX;AAAA,EAEA,SAAoB;AAEhB,QAAG,KAAK,KAAK,MAAM,EAAG,QAAO;AAC7B,UAAM,KAAK,KAAK,QAAQ,QAAQ;AAChC,QAAG,CAAC,GAAI,QAAO;AACf,SAAK,QAAQ,QAAQ,EAAE;AACvB,WAAO,KAAK,MAAM,EAAE;AAAA,EACxB;AAAA,EAEA,aAAuB;AACnB,WAAO,KAAK,QAAQ,KAAK,IAAI;AAAA,EACjC;AAAA,EAGA,iBAA4B;AACxB,QAAG,KAAK,KAAK,MAAM,EAAG,QAAO;AAC7B,UAAM,KAAK,KAAK,QAAQ,QAAQ;AAChC,QAAG,CAAC,GAAI,QAAO;AACf,SAAK,SAAS,KAAK,EAAE;AACrB,WAAO,KAAK,MAAM,EAAE;AAAA,EACxB;AAAA;AAAA,EAGA,OAAQ,IAAwB;AAE5B,QAAIA,UAAS,KAAK,QAAQ,EAAE;AAC5B,QAAGA,SAAO;AACN,UAAI,QAAQA,QAAO;AACnB,UAAI,OAAOA,QAAO;AAElB,UAAG,SAAS;AACR,aAAK,QAAQ,SAAS,KAAK;AAAA;AAE3B,aAAK,SAAS,OAAO,OAAO,CAAC;AAEjC,UAAI,OAAO,KAAK,MAAM,EAAE;AACxB,aAAO,KAAK,MAAM,EAAE;AAEpB,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX;AAAA,EAEA,YAAuB;AAEnB,QAAG,KAAK,QAAQ,KAAK,IAAI,GAAE;AACvB,UAAI,KAAK,KAAK,QAAQ,QAAQ;AAC9B,UAAG,OAAO,UAAa,OAAO,MAAO,QAAO;AAE5C,UAAI,OAAO,KAAK,MAAM,EAAE;AACxB,aAAO,KAAK,MAAM,EAAE;AACpB,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX;AAAA,EAEA,IAAK,IAAwB;AAEzB,QAAG,CAAC,KAAK,IAAI,EAAE,EAAG,QAAO;AACzB,WAAO,KAAK,MAAM,EAAE;AAAA,EACxB;AAAA;AAAA,EAGA,OAAgB;AACZ,WAAO,OAAO,KAAK,KAAK,KAAK,EAAE;AAAA,EACnC;AAAA;AAAA,EAGA,SAAkB;AACd,WAAO,KAAK,KAAK;AAAA,EACrB;AAAA;AAAA,EAGA,kBAA2B;AACvB,WAAO,KAAK,QAAQ,KAAK;AAAA,EAC7B;AAAA;AAAA,EAGA,mBAA4B;AACxB,WAAO,KAAK,SAAS;AAAA,EACzB;AAAA;AAAA,EAGA,UAAoB;AAChB,WAAO,KAAK,KAAK,MAAM;AAAA,EAC3B;AAAA,EAEA,QAAS,IAAwD;AAE7D,QAAI,QAAQ,KAAK,QAAQ,QAAQ,EAAE;AACnC,QAAG,EAAE,UAAU;AACX,aAAO,EAAE,OAAO,MAAM,UAAU;AAEpC,YAAQ,KAAK,SAAS,QAAQ,EAAE;AAChC,QAAG,EAAE,UAAU;AACX,aAAO,EAAE,OAAO,MAAM,WAAW;AACrC,WAAO;AAAA,EACX;AAAA,EAEA,UAAgB;AACZ,WAAO,OAAO,OAAO,KAAK,KAAK;AAAA,EACnC;AAAA,EAEA,QAAe;AACX,YAAQ,IAAI,KAAK,QAAQ,CAAC;AAAA,EAC9B;AAAA,EAEA,aAAwB;AACpB,WAAO,KAAK,QAAQ,QAAQ;AAAA,EAChC;AAAA,EAEA,oBAA0B;AACtB,WAAO,KAAK,QAAQ,QAAQ,EAAE,IAAK,QAAM,KAAK,MAAM,EAAE,CAAE;AAAA,EAC5D;AAAA,EAEA,cAAyB;AACrB,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,qBAA2B;AACvB,WAAO,KAAK,SAAS,IAAK,QAAM,KAAK,MAAM,EAAE,CAAE;AAAA,EACnD;AAAA,EAEA,iBAA4B;AACxB,WAAO,OAAO,KAAK,KAAK,KAAK;AAAA,EACjC;AAAA,EAEA,cAAwB;AACpB,QAAI,QAAQ,KAAK,KAAK;AACtB,QAAI,UAAU,KAAK,WAAW,EAAE;AAChC,QAAI,WAAW,KAAK,YAAY,EAAE;AAClC,QAAG,UAAW,UAAU;AACpB,aAAO;AAAA,QACN,QAAO;AAAA,EAChB;AAaJ;AAEA,IAAO,eAAQ;;;AC3Pf,IAAM,MAAM,IAAI,SAAiB;AAE7B,MAAG,QAAQ,IAAI,UAAU,QAAO;AAC5B,QAAI,UAAU,QAAQ,IAAI,OAAM,QAAQ,IAAI,OAAO;AACnD,YAAQ,IAAI,IAAI,OAAO,KAAK,GAAG,IAAI;AAAA,EACvC,MACK,QAAO;AAChB;AAGA,IAAO,cAAQ;;;ACZf,kBAA6B;AAE7B,IAAM,eAAe,MAAM;AACvB,aAAO,YAAAC,IAAO;AAClB;AAEC,IAAO,gBAAQ;;;ACJhB,eAAe,eAAe,WACA,UAAkB,KAClB,WAAmB,KAAoB;AACjE,SAAO,MAAM,IAAI,QAAS,OAAO,SAAS,WAAW;AACjD,QAAI;AACJ,QAAI;AAEJ,QAAG,UAAU,GAAE;AACX,oBAAc,WAAW,MAAM;AAC3B,sBAAc,YAAY;AAC1B,eAAO,SAAS;AAAA,MACpB,GAAG,OAAO;AAAA,IACd;AAEA,mBAAe,YAAa,YAAa;AAErC,UAAIC,UAAkB,MAAM,UAAU;AACtC,UAAGA,YAAW,MAAM;AAChB,sBAAc,YAAY;AAC1B,qBAAa,WAAW;AACxB,gBAAQA,OAAM;AAAA,MAClB;AAAA,IACJ,GAAG,QAAQ;AAAA,EACf,CAAC,EAAE,MAAO,WAAS;AACf,UAAM;AAAA,EACV,CAAC;AACL;AAEA,IAAO,yBAAQ;;;AC1Bf,SAAS,YAAY,cAAwC;AACzD,SAAO,OAAO,KAAK,YAAY,EAAE,IAAI,CAAC,SAAS;AAAA,IAC3C,OAAO;AAAA,IACP,YAAY,aAAa,GAAG,EAAE,SAAS,IAAI,IAAI,MAAM,aAAa,GAAG,EAAE,MAAM,EAAE,KAAK,MAAS,IAAI;AAAA,IACjG,UAAU,aAAa,GAAG;AAAA,EAC9B,EAAE;AAEN;AAEA,IAAO,sBAAQ;;;ACZf,SAAoB;AACpB,sBAAoB;;;ACQpB,eAAe,eAAe,EAAE,MAAM,MAAM,MAAM,QAAQ,GAErC;AACjB,SAAO,IAAI,QAAQ,CAAC,YAAY;AAC5B,UAAM,aAAa,IAAI,mBAAW;AAAA,MAC9B;AAAA,MACA;AAAA,MACA,IAAI,oBAAoB,KAAK,OAAO;AAAA,MACpC,SAAS;AAAA;AAAA,MACT,WAAW,CAACC,gBAA2B;AACnC,gBAAQ,IAAI;AACZ,QAAAA,YAAW,MAAM;AAAA,MACrB;AAAA,IAEJ,CAAC;AACD,eAAW,GAAG,iBAAiB,MAAM;AACjC,kBAAI,uBAAuB,IAAI,OAAO,IAAI,IAAI,IAAI,EAAE;AAAA,IACxD,CAAC;AAED,eAAW,GAAG,mBAAmB,MAAM;AACnC,kBAAI,yBAAyB,IAAI,OAAO,IAAI,IAAI,IAAI,EAAE;AACtD,cAAQ,KAAK;AACb,iBAAW,MAAM;AAAA,IACrB,CAAC;AACD,eAAW,UAAU;AAErB,eAAW,MAAM;AACb,cAAQ,KAAK;AACb,iBAAW,MAAM;AAAA,IACrB,GAAG,IAAK;AAAA,EACZ,CAAC;AACL;AAGA,IAAO,yBAAQ;;;AC5Cf,IAAM,gBAAgB,OAAO,eAAe,iBAAgB;AAAC,CAAC,EAAE;AAEhE,eAAe,aAAa,YAAqB,UAAU,CAAC,GAAG;AAC3D,MAAI;AACJ,MAAI,OAAO,eAAe;AACtB,UAAM,IAAI,UAAU,6CAA6C;AACrE,MAAG,iBAAiB,UAAU,GAAE;AAC5B,QAAI;AACA,iBAAW,KAAK,IAAI,UAAU,GAAG;AACjC,UAAI,SAAS,MAAM,SAAS,OAAO;AACnC,aAAO;AAAA,IACX,SAAS,OAAY;AACjB,YAAM;AAAA,IACV;AAAA,EACJ;AACA,MAAG;AACC,eAAW,IAAI,cAAc,GAAG,OAAO,KAAK,OAAO,GAAG,UAAU;AAChE,UAAMC,UAAS,MAAM,SAAS,GAAG,OAAO,OAAO,OAAO,CAAC;AACvD,WAAOA;AAAA,EACX,SAAS,OAAY;AACjB,UAAM;AAAA,EACV;AACJ;AAEA,SAAS,iBAAiB,MAAc;AACtC,MAAI;AACF,UAAM,KAAK,KAAK,IAAI,IAAI,GAAG;AAC3B,WAAO,OAAO,OAAO;AAAA,EACvB,SAAS,GAAG;AACV,WAAO;AAAA,EACT;AACF;AAEA,IAAO,wBAAQ;;;ACjCf,IAAAC,iBAAuB;AAEvB,kBAA6B;AAO7B,IAAM,gBAAN,MAAoB;AAAA,EAiBhB,YAAY,EAAE,MAAM,MAAM,MAAM,UAAU,GAEvC,SAAuC;AAhB1C;AAAA;AAAA,wBAAQ;AACR,wBAAQ;AACR,wBAAQ;AACR,wBAAQ;AACR,wBAAQ;AACR,wBAAO;AACP,wBAAO;AACP,wBAAO;AACP,wBAAO;AACP,wBAAO;AACP,wBAAO;AACP,wBAAO;AACP,wBAAQ;AAKJ,SAAK,OAAO,QAAQ;AACpB,SAAK,QAAQ,KAAK,SAAS;AAC3B,SAAK,OAAO,QAAQ;AACpB,SAAK,UAAU;AACf,SAAK,kBAAkB,SAAS,mBAAmB;AACnD,SAAK,OAAO,OAAM,OAAO;AACzB,SAAK,qBAAqB;AAC1B,SAAK,qBAAqB;AAC1B,SAAK,UAAU,IAAI,aAAiB;AACpC,SAAK,YAAY,aAAa,CAAC;AAC/B,SAAK,YAAY;AAAA,MACb,mBAAmB,KAAK;AAAA,IAC5B;AAEA,QAAG,KAAK,OAAM;AAEV,WAAK,iBAAa,0BAAa;AAC/B,WAAK,KAAK,IAAI,sBAAO,KAAK,YAAY,KAAK,SAAS;AACpD,WAAK,WAAW,OAAO,KAAK,MAAM,KAAK,MAAM,MAAM;AAC/C,YAAI,UAAU,KAAK,YAAY,QAAQ;AACvC,YAAG,CAAC,WAAW,OAAO,YAAY,UAAU;AACxC,kBAAQ,MAAM,uBAAuB;AACrC;AAAA,QACJ;AACA,aAAK,UAAU;AACf,aAAK,OAAO,QAAQ;AAAA,MACxB,CAAC;AAAA,IACL,OAAK;AACD,WAAK,KAAK,IAAI,sBAAO,KAAK,MAAM,KAAK,SAAS;AAE9C,WAAK,OAAQ,KAAK,GAAW,WAAW,QAAQ,EAAE;AAAA,IACtD;AAEA,SAAK,GAAG,GAAG,cAAc,KAAK,iBAAiB,KAAK,IAAI,CAAC;AACzD,SAAK,GAAG,GAAG,aAAa,MAAM,YAAI,iCAAiC,CAAC;AACpE,SAAK,GAAG,GAAG,cAAc,KAAK,oBAAoB,KAAK,IAAI,CAAC;AAE5D,SAAK,aAAa,KAAK,SAAS;AAAA,EACpC;AAAA,EAEA,MAAc,iBAAiB,QAAgB;AAC5C,gBAAI,6BAA6B;AAEhC,QAAI,aAAa,IAAI,mBAAW;AAAA,MAC5B;AAAA,MAAQ,MAAM,KAAK;AAAA,MAAM,WAAW,KAAK;AAAA,IAC7C,CAAC;AAED,UAAM,WAAW,UAAU;AAE3B,QAAI,KAAK,WAAW,YAAY;AAChC,gBAAI,4BAA4B,EAAE;AAElC,QAAG,MAAM,KAAM,OAAM,IAAI,MAAM,uBAAuB;AAEtD,QAAG,KAAK,QAAQ,IAAI,EAAE,GAAG;AACrB,UAAI,SAAS,KAAK,QAAQ,OAAO,EAAE;AACnC,gBAAU,OAAO,MAAM;AAAA,IAC3B;AAIA,SAAK,QAAQ,IAAI,IAAI,UAAU;AAE/B,QAAG,KAAK;AACJ,WAAK,mBAAmB,UAAU;AAAA,EAC1C;AAAA,EAEQ,oBAAoB,QAAgB;AACxC,YAAQ,IAAI,sCAAsC;AAClD,QAAI,WAAW,OAAO;AACtB,YAAQ,IAAI,wBAAwB,QAAQ;AAE5C,QAAI,OAAO,KAAK,QAAQ,QAAQ,EAC/B,OAAO,CAAC,WAAuB,OAAO,aAAa,QAAQ,EAAE,CAAC;AAE/D,QAAG,MAAM;AAEL,WAAK,MAAM;AACX,UAAI,KAAK,KAAK,YAAY;AAC1B,UAAG,OAAO;AACN,cAAM,IAAI,MAAM,4BAA4B;AAChD,WAAK,QAAQ,OAAO,KAAK,YAAY,CAAW;AAEhD,UAAG,KAAK;AACJ,aAAK,mBAAmB,IAAI;AAAA,IACpC;AAAA,EACJ;AAAA,EAEO,aAAa,WAAuB;AAEvC,cAAU,QAAQ,CAAC,aAAuB;AAEtC,UAAI,WAAW,UAAW,SAAiB;AAEvC,YAAIC,UAAS,MAAM,SAAS,SAAS,GAAG,IAAI;AAE5C,aAAK,GAAG,KAAK,SAAS,OAAOA,OAAM;AAAA,MACvC;AAEA,WAAK,GAAG,mBAAmB,SAAS,KAAK;AAEzC,WAAK,GAAG,GAAG,SAAS,OAAO,QAAQ;AAAA,IACvC,CAAC;AAED,SAAK,YAAY;AAEjB,SAAK,GAAG,KAAK,kBAAkB,KAAK,SAAS;AAAA,EACjD;AAAA,EAEO,UAAU,OAAe,MAAW;AAEvC,SAAK,GAAG,KAAK,OAAO,IAAI;AAAA,EAC5B;AAAA,EAEO,aAAa,WAAuB;AAGvC,UAAM,WAAW,IAAI,IAAI,KAAK,UAAU,IAAI,OAAK,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC;AAC9D,cAAU,QAAQ,OAAK,SAAS,IAAI,EAAE,OAAO,CAAC,CAAC;AAC/C,gBAAY,MAAM,KAAK,SAAS,OAAO,CAAC;AAExC,SAAK,aAAa,KAAK,SAAS;AAAA,EACpC;AAAA,EAEO,UAAU,IAAgC;AAC7C,WAAO,KAAK,QAAQ,IAAI,EAAE;AAAA,EAC9B;AAAA,EAEO,aAA4B;AAC/B,WAAO,KAAK,QAAQ,QAAQ;AAAA,EAChC;AAAA,EAEO,aAAa,UAAe;AAC/B,SAAK,qBAAqB;AAAA,EAC9B;AAAA,EAEO,aAAa,UAAe;AAC/B,SAAK,qBAAqB;AAAA,EAC9B;AAAA,EAEO,eAAe;AAElB,QAAI,SAAS,KAAK,QAAQ,QAAQ,EAAE,CAAC;AAErC,QAAG,CAAC,OAAQ,QAAO,CAAC;AAEpB,WAAO,OAAO,aAAa;AAAA,EAC/B;AAAA,EAEA,MAAM,QAAQ;AAEV,SAAK,GAAG,MAAM;AAAA,EAClB;AAEJ;AAEA,IAAO,iBAAQ;;;ACpLf,IAAM,UAAN,MAAc;AAAA,EAyBV,YAAY,EAAE,OAAO,IAAI,KAAK,OAAU,GAAoC;AAhB5E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAO;AAGP;AAAA;AAAA,wBAAO;AACP,wBAAO;AACP,wBAAQ;AAER;AAAA,wBAAO;AAEP;AAAA,wBAAO;AAEP;AAAA,wBAAO;AAEP;AAAA,wBAAO;AAKH,SAAK,OAAO;AACZ,SAAK,YAAY,CAAC;AAClB,SAAK,KAAK,MAAM,cAAK;AACrB,SAAK,SAAS;AACd,SAAK,cAAc,IAAI,aAAK;AAC5B,SAAK,4BAA4B;AACjC,SAAK,4BAA4B;AACjC,SAAK,uBAAuB;AAAA,EAChC;AAAA,EAEA,MAAM,QAAQ,EAAE,MAAM,MAAM,MAAM,GAAG,GAAqF;AAKtH,UAAM,aAAa,IAAI,mBAAW;AAAA,MAC9B,MAAO,KAAK;AAAA,MAAM;AAAA,MAAM;AAAA,MAAM,IAAI,KAAK;AAAA,MACvC,gBAAgB,KAAK;AAAA,IACzB,CAAC;AAED,UAAM,WAAW,UAAU;AAE3B,QAAI,cAAc,WAAW,cAAc;AAC3C,QAAG,gBAAgB;AACf,YAAM,IAAI,MAAM,0BAA0B;AAC9C,QAAG,SAAS;AACR,UAAG,gBAAgB;AACf,cAAM,IAAI,MAAM,yBAAyB,WAAW,QAAQ,IAAI,EAAE;AAAA;AAE1E,QAAG,OAAO,OAAW,eAAc;AAEnC,QAAG,KAAK,YAAY,IAAI,WAAW,GAAG;AAClC,UAAI,OAAO,KAAK,YAAY,OAAO,WAAW;AAC9C,cAAQ,KAAK,MAAM;AAAA,IACvB;AAEA,eAAW,aAAa,KAAK,SAAS;AAEtC,SAAK,YAAY,IAAI,aAAa,UAAU;AAE5C,SAAK,6BAA6B,KAAK,0BAA0B,UAAU;AAE3E,WAAO;AAAA,EACX;AAAA,EAEA,MAAa,WAAW,UAA0D;AAC9E,gBAAI,aAAa,KAAK,IAAI,gCAAgC,QAAQ;AAElE,QAAI,cAAc,MAAM,QAAQ,IAAI,SAAS;AAAA,MACzC,OAAM,YAAW,MAAM,KAAK,QAAQ;AAAA,QAChC,MAAM,QAAQ;AAAA,QACd,MAAM,QAAQ;AAAA,QACd,MAAM,QAAQ;AAAA,MAClB,CAAC;AAAA,IACL,CAAC,EAAE,MAAM,CAAC,QAAQ;AACd,kBAAI,aAAa,KAAK,IAAI,mCAAmC,GAAG;AAChE,aAAO,CAAC;AAAA,IACZ,CAAC;AAED,WAAO;AAAA,EACX;AAAA,EAEO,aACH,MAAc,MAAc,MAC5B,YAAwB,CAAC,GAC3B;AAEE,SAAK,SAAS,IAAI,eAAO,EAAE,MAAM,MAAM,MAAM,UAAU,CAAC;AAAA,EAC5D;AAAA,EAEO,QAAQ;AAEX,QAAG,KAAK,QAAO;AACX,WAAK,OAAO,MAAM;AAAA,IACtB;AAEA,SAAK,YAAY,QAAQ,EAAE,QAAQ,CAAC,eAA2B;AAC3D,iBAAW,MAAM;AAAA,IACrB,CAAC;AAAA,EACL;AAAA,EAEO,WAAW,MAA0B;AAExC,QAAI,UAAU,KAAK,YAAY,IAAI,IAAI;AAEvC,QAAG,YAAY;AACX,YAAM,IAAI,MAAM,WAAW,IAAI,kBAAkB,KAAK,IAAI,EAAE;AAChE,WAAO;AAAA,EACX;AAAA,EAEO,cAA4B;AAE/B,WAAO,KAAK,YAAY,QAAQ;AAAA,EACpC;AAAA,EAEO,QAAQ,IAAwB;AAEnC,QAAG,KAAK,WAAW,KAAM,OAAM,IAAI,MAAM,uBAAuB;AAChE,QAAI,SAAS,KAAK,OAAO,UAAU,EAAE;AAErC,QAAG,WAAW,KAAM,OAAM,IAAI,MAAM,kBAAkB;AAEtD,WAAO;AAAA,EACX;AAAA,EAEO,WAAyB;AAE5B,QAAI,QAAQ,KAAK,QAAQ,WAAW,EAChC,OAAO,CAAC,SAAqB,KAAK,eAAe,QAAQ;AAC7D,WAAO,SAAS,CAAC;AAAA,EACrB;AAAA,EAEO,iBAA+B;AAElC,WAAO,KAAK,YAAY,QAAQ,EAAE,OAAO,KAAK,QAAQ,WAAW,KAAK,CAAC,CAAC;AAAA,EAC5E;AAAA,EAEO,aAAa,MAAc;AAE9B,QAAI,aAAa,KAAK,YAAY,OAAO,IAAI;AAC7C,QAAG,WAAY,YAAW,MAAM;AAEhC,SAAK,6BACD,KAAK,0BAA0B,UAAU;AAAA,EACjD;AAAA,EAEO,gBAAgB,IAAY;AAE/B,QAAI,aAAa,KAAK,YAAY,OAAO,EAAE;AAC3C,QAAG,WAAY,YAAW,MAAM;AAAA,EACpC;AAAA,EAEO,kBAAkB,WAAuB;AAK5C,SAAK,YAAY;AAEjB,QAAG,KAAK,OAAQ,MAAK,OAAO,aAAa,KAAK,SAAS;AAEvD,SAAK,YAAY,QAAQ,EAAE,QAAQ,CAAC,eAA2B;AAC3D,iBAAW,aAAa,SAAS;AAAA,IACrC,CAAC;AAAA,EACL;AAAA,EAGO,aAAa,WAAuB;AAEvC,SAAK,YAAY,KAAK,UAAU,OAAO,SAAS;AAEhD,QAAG,KAAK,OAAQ,MAAK,OAAO,aAAa,SAAS;AAElD,SAAK,YAAY,QAAQ,EAAE,QAAQ,CAAC,eAA2B;AAC3D,iBAAW,aAAa,SAAS;AAAA,IACrC,CAAC;AAAA,EAEL;AAAA,EAEO,yBAA8B;AAEjC,QAAI,mBAAmB,KAAK,QAAQ,aAAa,KAAK,CAAC;AACvD,QAAI,wBAAwB,KAAK,YAAY,QAAQ,EAAE,IAAI,CAAC,eAA2B;AACnF,kBAAI,2BAA2B,UAAU;AACzC,aAAO,EAAE,IAAI,WAAW,IAAI,WAAW,WAAW,aAAa,EAAE;AAAA,IACrE,CAAC;AAED,WAAO,EAAE,QAAQ,kBAAkB,aAAa,sBAAsB;AAAA,EAC1E;AAAA;AAAA,EAIO,iBAAiB,UAA4C;AAChE,QAAG,KAAK,WAAW,KAAM,OAAM,IAAI,MAAM,uBAAuB;AAChE,SAAK,OAAO,aAAa,QAAQ;AAAA,EACrC;AAAA,EAEO,iBAAiB,UAA4C;AAChE,QAAG,KAAK,WAAW,KAAM,OAAM,IAAI,MAAM,uBAAuB;AAChE,SAAK,OAAO,aAAa,QAAQ;AAAA,EACrC;AAAA,EAEO,oBAAoB,UAA4C;AAEnE,SAAK,4BAA4B;AAAA,EACrC;AAAA,EAEO,oBAAoB,UAA4C;AACnE,SAAK,4BAA4B;AAAA,EACrC;AAAA,EAEO,eAAe,UAA2C;AAC7D,SAAK,uBAAuB;AAAA,EAChC;AAEJ;AAEA,IAAO,kBAAQ;;;ACjOf,IAAO,kBAAQ;;;ACJf,2BAAqB;AACrB,0BAAoB;AAUpB,IAAM,UAAN,MAAc;AAAA,EAWV,YAAY,SAAa;AAVzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGI,SAAK,oBAAoB,QAAQ,qBAAqB;AACtD,SAAK,kBAAkB,QAAQ,mBAAmB;AAClD,SAAK,iBAAiB,QAAQ,kBAAkB;AAChD,SAAK,YAAY,QAAQ,aAAa;AACtC,SAAK,OAAO,oBAAAC,QAAQ,IAAI,QAAQ;AAChC,SAAK,iBAAiB,oBAAAA,QAAQ,IAAI,mBAAmB,UAAU;AAC/D,SAAK,uBAAuB;AAC5B,SAAK,cAAc,oBAAAA;AACnB,SAAK,YAAY,CAAC;AAAA,EACtB;AAAA,EAGO,MAAO,cAAuB;AAAA,IACjC;AAAA,IAAgB;AAAA,IAAgB;AAAA,IAAsB;AAAA,EAC1D,IAAkB,CAAC,GAAE;AACjB,SAAK,IAAI,0BAA0B,YAAY;AAC/C,SAAK,IAAI,mBAAmB,cAAc,EAAE;AAC5C,SAAK,IAAI,kCAAkC,KAAK,qBAAqB,CAAC;AACtE,QAAG,mBAAmB,OAAW,kBAAiB;AAClD,SAAK,uBAAuB,wBAAwB;AAGpD,QAAG,KAAK,qBAAqB,KAAK,eAAgB,kBAAiB;AAAA,QAC9D,kBAAiB;AACtB,SAAK,IAAI,qCAAqC,cAAc;AAE5D,QAAG,KAAK,wBAAwB,MAAM,MAAO;AAC7C,QAAI;AACJ,aAAS,IAAI,GAAG,IAAI,gBAAgB,KAAI;AACpC,uBAAa;AAAA,QACT,oBAAAA,QAAQ,KAAK,CAAC;AAAA,QAAG,CAAC;AAAA,QAAG;AAAA,UACjB,KAAK;AAAA,YACD,UAAU;AAAA,YACV,MAAM;AAAA,YACN,gBAAgB,GAAG,cAAc;AAAA,YACjC,UAAU,KAAK,UAAU,QAAQ;AAAA,UACrC;AAAA,QACJ;AAAA,MACJ;AACA,WAAK,UAAU,KAAK,UAAU;AAAA,IAClC;AAAA,EACJ;AAAA,EAGQ,0BAAyB;AAC7B,QAAG,KAAK,wBAAwB,KAAK,gBAAgB;AACjD,aAAO;AACX,QAAG,KAAK,qBAAqB,GAAE;AAC3B,WAAK,IAAI,mDAAmD;AAC5D,aAAO;AAAA,IACX,MAAM,MAAK,IAAI,oCAAoC;AACnD,QAAG,KAAK,gBAAe;AACnB,WAAK,IAAI,2CAA2C;AACpD,aAAO;AAAA,IACX,MAAM,MAAK,IAAI,+CAA+C;AAC9D,WAAO;AAAA,EACX;AAAA,EAGA,mBAAmB;AACf,WAAO,KAAK;AAAA,EAChB;AAAA,EAGA,gBAAgB;AACZ,WAAO,KAAK;AAAA,EAChB;AAAA,EAEO,GAAG,cAAsB;AAC5B,SAAK,IAAI,0BAA0B,YAAY,EAAE;AACjD,QAAG,iBAAiB,UAAW,QAAO,KAAK,qBAAqB;AAChE,WAAO,oBAAAA,QAAQ,IAAI,SAAS;AAAA,EAChC;AAAA,EAEQ,uBAAuB;AAC3B,QAAI,KAAK,YAAY,IAAI,aAAa;AAClC,aAAO;AACX,QAAG,KAAK,YAAY,IAAI,aAAa;AACjC,aAAO;AACX,QAAI,KAAK,YAAY,IAAI,aAAa;AAClC,aAAO;AACX,WAAO;AAAA,EACX;AAAA,EAEO,YAAY;AACf,WAAO,KAAK,qBAAqB;AAAA,EACrC;AAAA,EAEQ,kBAAkB;AACtB,WAAO,oBAAAA,QAAQ,IAAI,aAAa;AAAA,EACpC;AAAA,EAEQ,IAAI,SAAiB;AACzB,SAAK,aAAa,QAAQ,IAAI,IAAI,oBAAAA,QAAQ,GAAG,KAAK,KAAK,IAAI,KAAK,OAAO,EAAE;AAAA,EAC7E;AAAA,EAEO,cAAc;AACjB,WAAO,oBAAAA,QAAQ,IAAI;AAAA,EACvB;AAEJ;AAEA,IAAO,yBAAQ;;;AC5Hf,IAAO,kBAAQ;;;ACSf,IAAM,qBAAN,MAAyB;AAAA,EASrB,YAAY,QAAoB;AAPhC;AAAA,wBAAO;AACP,wBAAO;AACP,wBAAO;AACP,wBAAQ,WAA0B;AAClC,wBAAQ,WAA0B;AAClC,wBAAQ,YAA8C,CAAC;AAGnD,SAAK,OAAO;AAEZ,SAAK,OAAO,OAAO;AACnB,SAAK,OAAO,OAAO;AAAA,EACvB;AAAA,EAEA,MAAa,QAAQ;AAEjB,SAAK,UAAU,IAAI,gBAAQ,EAAE,MAAM,KAAK,KAAK,CAAC;AAC9C,SAAK,QAAQ,MAAM,KAAK,MAAM;AAAA,MAC1B,sBAAsB;AAAA;AAAA,IAC1B,CAAC;AAED,QAAG,KAAK,QAAQ,GAAG,gBAAgB,GAAE;AAGjC,WAAK,UAAU,IAAI,gBAAQ,EAAC,MAAM,KAAK,OAAO,WAAU,CAAC;AAEzD,UAAI,YAAY,KAAK,aAAa;AAElC,WAAK,QAAQ,aAAa,KAAK,MAAM,KAAK,MAAM,KAAK,MAAM,SAAS;AAAA,IACxE;AACA;AAAA,EACJ;AAAA,EAEQ,eAA2B;AAG/B,QAAI,YAAY,CAAC;AAAA;AAAA,MAEb,OAAO;AAAA,MACP,QAAQ,CAAC,QAAQ,QAAQ,MAAM;AAAA,MAC/B,UAAU,KAAK,gBAAgB,KAAK,IAAI;AAAA,IAC5C,GAAE;AAAA,MACE,OAAO;AAAA,MACP,UAAU,KAAK,YAAY,KAAK,IAAI;AAAA,IACxC,GAAE;AAAA,MACE,OAAO;AAAA,MACP,QAAQ,CAAC,MAAM;AAAA,MACf,UAAU,KAAK,cAAc,KAAK,IAAI;AAAA,IAC1C,GAAE;AAAA;AAAA,MACE,OAAO;AAAA,MACP,UAAU,KAAK,KAAK,KAAK,IAAI;AAAA,IACjC,CAAC;AACD,WAAO;AAAA,EACX;AAAA,EAEQ,gBAAgB,EAAE,MAAM,MAAM,KAAK,GAAmB;AAC1D,QAAG,KAAK,YAAY,KAAM,OAAM,IAAI,MAAM,4BAA4B;AAEtE,QAAG,KAAK,SAAS,IAAI,EAAG,OAAM,IAAI,MAAM,WAAW,IAAI,wBAAwB;AAE/E,SAAK,SAAS,IAAI,IAAI,EAAE,MAAM,MAAM,KAAK;AAEzC,QAAG,KAAK,YAAY,KAAM,OAAM,IAAI,MAAM,4BAA4B;AACtE,QAAG,KAAK,QAAQ,WAAW,KAAM,OAAM,IAAI,MAAM,2BAA2B;AAC5E,SAAK,QAAQ,OAAO,UAAU,eAAe,EAAE,MAAM,MAAM,KAAK,CAAC;AACjE;AAAA,EACJ;AAAA,EAEQ,cAAiC;AACrC,WAAO,OAAO,OAAO,KAAK,QAAQ;AAAA,EACtC;AAAA,EAEQ,cAAc,MAAc;AAChC,QAAG,CAAC,KAAK,SAAS,IAAI,EAAG,QAAO;AAChC,QAAG,KAAK,YAAY,KAAM,OAAM,IAAI,MAAM,4BAA4B;AACtE,QAAG,KAAK,QAAQ,WAAW,KAAM,OAAM,IAAI,MAAM,2BAA2B;AAE5E,WAAO,KAAK,SAAS,IAAI;AAEzB,SAAK,QAAQ,OAAO,UAAU,kBAAkB,EAAE,KAAK,CAAC;AACxD,WAAO;AAAA,EACX;AAAA,EAGO,OAAM;AAET,eAAW,MAAM;AACb,UAAG,KAAK,QAAS,MAAK,QAAQ,MAAM;AAEpC,cAAQ,KAAK,CAAC;AAAA,IAClB,GAAG,GAAI;AACP,WAAO;AAAA,EACX;AAEJ;AAIA,IAAO,8BAAQ;;;ACpGf,IAAM,sBAAN,MAA0B;AAAA;AAAA;AAAA,EAStB,YAAY,EAAE,MAAM,MAAM,KAAK,GAAW;AAP1C;AAAA,wBAAO,QAAe;AACtB,wBAAO;AACP,wBAAO;AACP,wBAAO,WAAoB,IAAI,gBAAQ,EAAE,MAAM,iBAAiB,CAAC;AAEjE;AAAA,wBAAO,cAAa;AAGhB,SAAK,OAAO,QAAQ;AACpB,SAAK,OAAO;AACZ,SAAK,OAAO;AAAA,EAChB;AAAA,EAEA,MAAa,UAAS;AAElB,QAAG,KAAK,YAAY,OAAW,OAAM,IAAI,MAAM,iBAAiB;AAChE,UAAM,KAAK,QAAQ,QAAQ;AAAA,MACvB,MAAM,KAAK;AAAA,MACX,MAAM,KAAK;AAAA,MACX,MAAM,KAAK;AAAA,IACf,CAAC;AAAA,EACL;AAAA,EAEA,MAAa,SAAS,EAAE,MAAM,MAAM,KAAK,GAAW;AAChD,QAAG,KAAK,YAAY,OAAW,OAAM,IAAI,MAAM,iBAAiB;AAChE,QAAI,aAAa,KAAK,QAAQ,WAAW,KAAK,IAAI;AAClD,QAAG,eAAe,KAAM,OAAM,IAAI,MAAM,WAAW,KAAK,IAAI,YAAY;AACxE,WAAO,MAAM,WAAW,KAAK,oBAAoB,EAAE,MAAM,MAAM,KAAK,CAAC;AAAA,EACzE;AAAA,EAEA,MAAa,cAAc;AAEvB,UAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,KAAK,UAAU,CAAC;AACnE,QAAG,KAAK,YAAY,OAAW,OAAM,IAAI,MAAM,iBAAiB;AAChE,QAAI,aAAa,KAAK,QAAQ,WAAW,KAAK,IAAI;AAClD,QAAG,eAAe,KAAM,OAAM,IAAI,MAAM,WAAW,KAAK,IAAI,YAAY;AACxE,QAAI,WAAW,MAAM,WAAW,KAAK,cAAc;AACnD,WAAO;AAAA,EACX;AAAA,EAEA,MAAa,OAAO;AAChB,QAAG,KAAK,YAAY,OAAW,OAAM,IAAI,MAAM,iBAAiB;AAChE,QAAI,aAAa,KAAK,QAAQ,WAAW,KAAK,IAAI;AAClD,QAAG,eAAe,KAAM,OAAM,IAAI,MAAM,WAAW,KAAK,IAAI,YAAY;AACxE,WAAO,MAAM,WAAW,KAAK,MAAM;AAAA,EACvC;AAEJ;AAEA,IAAO,8BAAQ;;;AC1Df,IAAO,wBAAQ;;;ACqBf,IAAI;AAEJ,IAAM,kBAAkB,CAAC,aAAkC;AAEvD,QAAM,oBAAoB,sBAAsB,QAAQ;AACxD,UAAQ,IAAI,MAAM,CAAC,GAAG,iBAAiB;AACvC,SAAO;AACX;AAEA,IAAM,wBAAwB,CAAC,cAAmC;AAAA,EAC9D,IAAI,QAAa,MAAW;AAExB,WAAO,CAAC,MAAW,OAAa,UAAgB;AAC5C,UAAI,SAAS;AACb,UAAI,SAAS;AACb,UAAI,SAAS;AACb,UAAI,SAAS;AAEb,UAAG,OAAO,SAAS,cAAc,OAAO,SAAS;AAC7C,cAAM,IAAI,MAAM,iDAAiD;AACrE,UAAG,UAAU,UAAa,OAAO,UAAU;AACvC,cAAM,IAAI,MAAM,oCAAoC;AACxD,UAAG,UAAU,UAAa,OAAO,UAAU;AACvC,cAAM,IAAI,MAAM,mCAAmC;AAEvD,eAAS,QAAQ,QAAQ,QAAQ,MAAM;AAEvC,aAAO;AAAA,IACX;AAAA,EACJ;AACJ;AAEA,IAAO,0BAAQ;;;ACpDf,6BAAiD;AAiBjD,IAAM,OAAN,MAAW;AAAA,EAkBP,cAAa;AAjBb,wBAAO;AACP,wBAAO;AACP,wBAAO,UAAqB;AAC5B,wBAAO,aAAwB,CAAC;AAChC,wBAAO,gBAAuB,KAAK,IAAI;AACvC,wBAAO;AACP,wBAAO,qBAA6B;AAEpC;AAAA,wBAAO,wBAA0E;AAEjF;AAAA,wBAAO,oBAAkF;AACzF,wBAAO,oBAAkD;AAEzD;AAAA,wBAAO,YAA6B,CAAC;AACrC,wBAAO,eAA0C,CAAC;AAClD,wBAAO,WAAoE,CAAC;AAM5E;AAAA,wBAAO,SAAQ,MAAM,KAAK;AAC1B,wBAAO,aAAY,MAAM,KAAK;AAC9B,wBAAO,iBAAgB,MAAM,KAAK,IAAI,IAAI,KAAK;AAC/C,wBAAO,UAAS,MAAM,KAAK,WAAW;AACtC,wBAAO,aAAY,MAAM,KAAK,WAAW;AACzC,wBAAO,WAAU,MAAM,KAAK,WAAW;AACvC,wBAAQ,qBAAoB,MAAM,KAAK,eAAe,KAAK,IAAI;AAC/D,wBAAQ,gBAAe,CAAC,WAAuB,KAAK,SAAS;AAC7D,wBAAO,eAAc,YAAY;AAC7B,YAAM,uBAAe,MAAM,KAAK,OAAO,GAAG,GAAI,EAC7C,MAAM,MAAM;AAAE,cAAM,IAAI,MAAM,sBAAsB;AAAA,MAAE,CAAC;AACxD,aAAO;AAAA,IACX;AAEA,wBAAO,OAAM,OAAO,QAAgB,cAAmB;AACnD,UAAG,KAAK,SAAS,SAAU,QAAO,MAAM,KAAK,WAAW,EAAE,QAAQ,UAAU,CAAC;AAAA,eACrE,KAAK,SAAS,SAAU,QAAO,MAAM,KAAK,WAAW,EAAE,QAAQ,UAAU,CAAC;AAAA,UAC7E,OAAM,IAAI,MAAM,2BAA2B;AAAA,IACpD;AAEA,wBAAO,QAAO,OAAO,QAAgBC,UAAiB;AAClD,UAAG,KAAK,SAAS,SAAU,QAAO,MAAM,KAAK,YAAYA,KAAI;AAAA,eACrD,KAAK,SAAS,SAAU,QAAO,MAAM,KAAK,YAAYA,KAAI;AAAA,UAC7D,OAAM,IAAI,MAAM,2BAA2B;AAAA,IACpD;AAEA,wBAAO,eAAc,OAAO,aAA+B;AACvD,UAAG,KAAK,SAAS,SAAU,QAAO,MAAM,KAAK,mBAAmB,QAAQ;AAAA,eAChE,KAAK,SAAS,SAAU,QAAO,MAAM,KAAK,mBAAmB,QAAQ;AAAA,UACxE,OAAM,IAAI,MAAM,2BAA2B;AAAA,IACpD;AAEA,wBAAO,QAAO,YAAY;AACtB,UAAG,KAAK,SAAS,SAAU,QAAO,MAAM,KAAK,YAAY;AAAA,eACjD,KAAK,SAAS,SAAU,QAAO,MAAM,KAAK,YAAY;AAAA,UACzD,OAAM,IAAI,MAAM,2BAA2B;AAAA,IACpD;AAEA,wBAAO,QAAO,YAAY;AACtB,UAAG,KAAK,SAAS,SAAU,QAAO,MAAM,KAAK,YAAY;AAAA,eACjD,KAAK,SAAS,SAAU,QAAO,MAAM,KAAK,YAAY;AAAA,UACzD,OAAM,IAAI,MAAM,2BAA2B;AAAA,IACpD;AAwNA;AAAA,wBAAO,YAAW,OAAO,KAAU,QAAa,SAAS,MAAM,KAAK,KAAK,cAAc,EAAE,KAAK,MAAM,CAAC;AACrG,wBAAO,YAAW,OAAO,MAAc,OAAO,MAAM,KAAK,KAAK,cAAc,GAAG;AAiF/E;AAAA,wBAAO,UAAS,KAAK;AACrB,wBAAO,eAAc,KAAK;AAC1B,wBAAO,YAAW,KAAK;AACvB,wBAAO,YAAW,KAAK;AACvB,wBAAO,OAAM,KAAK;AAClB,wBAAO,OAAM,KAAK;AAClB,wBAAO,SAAQ,KAAK;AACpB,wBAAO,WAAU,KAAK;AAAA,EA/VR;AAAA;AAAA,EAiDP,kBAAkB,YAAwB,SAAiB;AAC9D,QAAG,KAAK,SAAS,UAAa,KAAK,SAAS;AACxC,YAAM,IAAI,MAAM,oCAAoC;AAExD,SAAK,OAAO;AAEZ,SAAK,KAAK,WAAW,YAAY;AAEjC,SAAK,UAAU;AAEf,QAAG,KAAK,qBAAqB,QAAQ,KAAK,qBAAqB;AAC3D,YAAM,IAAI,MAAM,uCAAuC;AAE3D,SAAK,YAAY;AAAA;AAAA,MACb,EAAE,OAAO,eAAe,YAAY,CAAC,QAAQ,GAAG,UAAU,KAAK,mBAAmB,KAAK,IAAI,EAAE;AAAA,MAC7F,EAAE,OAAO,SAAS,YAAY,CAAC,GAAG,UAAU,MAAM,QAAQ;AAAA,MAC1D,EAAE,OAAO,cAAc,YAAY,CAAC,OAAO,OAAO,GAAG,UAAU,KAAK,iBAAiB;AAAA,MACrF,EAAE,OAAO,cAAc,YAAY,CAAC,KAAK,GAAG,UAAU,KAAK,iBAAiB;AAAA,IAChF;AAEI,eAAW,aAAa,KAAK,SAAS;AAAA,EAC9C;AAAA,EAEO,wBAAwB,UAAmD;AAC9E,SAAK,uBAAuB;AAAA,EAChC;AAAA,EAEO,kBAAkB,EAAE,KAAK,IAAI,GAAwE;AACxG,SAAK,mBAAmB,CAAC,EAAE,KAAK,MAAM,MAAmC,IAAI,KAAK,KAAK;AACvF,SAAK,mBAAmB;AAAA,EAC5B;AAAA,EAEO,mBAAmB,QAAmB;AAEzC,SAAK,aAAa,MAAM;AACxB,SAAK,wBAAwB,KAAK,qBAAqB,QAAQ,IAAI;AAAA,EACvE;AAAA,EAEO,cAAa;AAEhB,SAAK,kBAAkB;AACvB,WAAO,KAAK,cAAc;AAAA,EAC9B;AAAA,EAEA,MAAc,WAAW,EAAC,QAAQ,UAAS,GAAoC;AAG3E,SAAK,mBAAmB,SAAS;AACjC,QAAI,MAAM,MAAM,KAAK,KAAK,QAAQ,EAAE,QAAQ,UAAU,CAAC;AAEvD,SAAK,mBAAmB,MAAM;AAE9B,QAAG,IAAI,YAAY;AACf,UAAI,YAAQ,yCAAiB,IAAI,KAAK;AAE1C,WAAO;AAAA,EACX;AAAA,EAEA,MAAc,YAAYA,OAAa;AAGnC,SAAK,mBAAmB,SAAS;AACjC,QAAI,MAAM,MAAM,KAAK,KAAK,SAASA,KAAI;AAEvC,SAAK,mBAAmB,MAAM;AAE9B,QAAG,IAAI,YAAY;AACf,UAAI,YAAQ,yCAAiB,IAAI,KAAK;AAE1C,WAAO;AAAA,EACX;AAAA,EAEA,MAAc,mBAAmB,UAA2B;AAExD,QAAI,MAAM,MAAM,KAAK,KAAK,iBAAiB,QAAQ;AACnD,WAAO;AAAA,EACX;AAAA,EAEA,MAAa,cAAa;AAEtB,QAAI,MAAM,MAAM,KAAK,KAAK,OAAO;AACjC,QAAG,QAAQ,OAAQ,MAAK,kBAAkB;AAC1C,WAAO;AAAA,EACX;AAAA,EAEA,MAAa,cAAa;AAEtB,QAAI,MAAM,MAAM,KAAK,KAAK,SAAS,IAAI,EAEtC,MAAM,CAAC,UAAU;AAAE,UAAG,UAAU,UAAW,QAAO;AAAA,UAAW,OAAM;AAAA,IAAO,CAAC;AAC5E,WAAO;AAAA,EACX;AAAA,EAEA,MAAa,iBAAiB,SAA0B;AAEpD,QAAI,WAAW,QAAQ,IAAI,CAAAC,aAAW,IAAI,QAAQ,OAAO,YAAY;AACjE,UAAIC,UAAS,MAAM,KAAK,KAAK,oBAAoBD,QAAO;AACxD,cAAQC,OAAM;AAAA,IAClB,CAAC,CAAC;AAEF,WAAO,MAAM,QAAQ,IAAI,QAAQ;AAAA,EACrC;AAAA,EAEA,MAAa,KAAK,QAAgB,YAAiB,MAAK;AAEpD,QAAG,KAAK,YAAY,OAAW,OAAM,IAAI,MAAM,8BAA8B;AAC7E,QAAG,KAAK,OAAO,OAAW,OAAM,IAAI,MAAM,yBAAyB;AACnE,QAAG,KAAK,SAAS,OAAW,OAAM,IAAI,MAAM,2BAA2B;AAEvE,QAAI,aAAqC;AACzC,QAAG,KAAK,SAAS;AACb,mBAAa,KAAK,QAAQ,QAAQ,KAAK,EAAE;AAAA,aACrC,KAAK,SAAS;AAClB,mBAAa,KAAK,QAAQ,WAAW,QAAQ;AACjD,QAAG,eAAe;AACd,YAAM,IAAI,MAAM,+CAA+C;AAEnE,WAAO,MAAM,WAAW,KAAK,QAAQ,SAAS;AAAA,EAClD;AAAA;AAAA,EAIA,MAAa,gBAAgB,MAAc,MAAa;AAGpD,SAAK,KAAK,KAAK,MAAM,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,UAAU,CAAC;AAC3D,SAAK,UAAU,IAAI,gBAAQ,EAAC,MAAM,QAAQ,IAAI,KAAK,GAAE,CAAC;AAEtD,SAAK,QAAQ,QAAQ,EAAE,MAAM,MAAM,IAAI,SAAS,CAAC;AAEjD,SAAK,OAAO;AAEZ,SAAK,YAAY;AAAA,MACb,EAAE,OAAO,QAAQ,YAAY,CAAC,UAAU,WAAW,GAAG,UAAU,KAAK,WAAW,KAAK,IAAI,EAAE;AAAA,MAC3F,EAAE,OAAO,SAAS,YAAY,CAAC,aAAa,GAAG,UAAU,KAAK,YAAY,KAAK,IAAI,EAAE;AAAA,MACrF,EAAE,OAAO,iBAAiB,YAAY,CAAC,UAAU,GAAG,UAAU,KAAK,mBAAmB,KAAK,IAAI,EAAE;AAAA,MACjG,EAAE,OAAO,YAAY,YAAY,CAAC,GAAG,UAAU,KAAK,OAAO,KAAK,IAAI,EAAE;AAAA,MACtE,EAAE,OAAO,YAAY,YAAY,CAAC,GAAG,UAAU,KAAK,OAAO,KAAK,IAAI,EAAE;AAAA,MACtE,EAAE,OAAO,aAAa,YAAY,CAAC,QAAQ,GAAG,UAAU,KAAK,QAAQ,KAAK,IAAI,EAAE;AAAA,MAChF,EAAE,OAAO,SAAS,YAAY,CAAC,GAAG,UAAU,MAAM,OAAO;AAAA,MACrD,EAAE,OAAO,SAAS,YAAY,CAAC,GAAG,UAAU,KAAK,YAAY,KAAK,IAAI,EAAE;AAAA,IAChF;AAEA,SAAK,QAAQ,kBAAkB,KAAK,SAAS;AAAA,EACjD;AAAA,EAEA,MAAc,WAAW,EAAC,QAAQ,UAAS,GAAoC;AAG3E,UAAM,uBAAe,MAAM,KAAK,mBAAmB,GAAK,EAAE,MAAM,MAAM;AAClE,YAAM,IAAI,MAAM,UAAU,KAAK,EAAE,qCAAqC;AAAA,IAC1E,CAAC;AACD,QAAI;AAEA,WAAK,aAAa,SAAS;AAE3B,UAAI,WAAW,KAAK,SAAS;AAAA,QACzB,CAAC,MAAsB,IAAI,sBAAc,EAAE,MAAM,KAAK,OAAkB;AAAA,MAC5E,EAAE,OAAO,CAAC,KAAU,MAAqB;AACrC,YAAI,EAAE,IAAI,IAAI;AACd,eAAO;AAAA,MACX,GAAG,CAAC,CAAC;AAEL,YAAMA,UAAS,MAAM,KAAK,QAAQ,MAAM,EAAE,WAAW,EAAE,GAAG,UAAU,OAAO,MAAM,MAAM,KAAK,CAAC;AAE7F,WAAK,YAAY,MAAM,IAAI;AAE3B,aAAO,EAAE,QAAAA,SAAQ,SAAS,MAAM;AAAA,IACpC,SAAQ,OAAM;AACV,WAAK,aAAa,OAAO;AAEzB,aAAO,EAAE,WAAO,uCAAe,KAAK,GAAG,SAAS,KAAK;AAAA,IACzD,UAAE;AAEE,WAAK,aAAa,MAAM;AAAA,IAC5B;AAAA,EACJ;AAAA,EAGA,MAAc,YAAY,aAAoB;AAG1C,QAAG,OAAO,gBAAgB;AACtB,aAAO,EAAE,SAAS,MAAM,WAAO,uCAAe,IAAI,MAAM,6BAA6B,CAAC,EAAE;AAE5F,UAAM,uBAAe,MAAM,KAAK,mBAAmB,GAAK,EAAE,MAAM,MAAM;AAClE,YAAM,IAAI,MAAM,6CAA6C;AAAA,IACjE,CAAC;AACD,QAAI,WAAW,KAAK,SAAS;AAAA,MACzB,CAAC,MAAsB,IAAI,sBAAc,EAAE,MAAM,KAAK,OAAkB;AAAA,IAC5E,EAAE,OAAO,CAAC,KAAU,MAAqB;AACrC,UAAI,EAAE,IAAI,IAAI;AACd,aAAO;AAAA,IACX,GAAG,CAAC,CAAC;AACL,QAAI,YAAY,EAAE,GAAG,UAAU,QAAQ,MAAM,MAAM,KAAK;AACxD,QAAI;AAEA,UAAIA,UAAS,MAAM,sBAAc,aAAa,SAAS;AACvD,aAAO,EAAE,QAAQA,SAAQ,SAAS,MAAM;AAAA,IAC5C,SAAQ,GAAI;AACR,aAAO,EAAE,SAAS,MAAM,WAAO,uCAAe,CAAC,EAAE;AAAA,IACrD;AAAA,EACJ;AAAA,EAEA,MAAa,WAAU;AAInB,QAAG,KAAK,QAAQ,UAAU,MAAM;AAC5B,YAAM,KAAK,WAAW,EAAE,QAAQ,YAAY,WAAW,KAAK,CAAC;AAAA,EACrE;AAAA,EAMO,WAAW,SAAoD;AAElE,SAAK,UAAU;AAEf,aAAQ,UAAU;AACd,WAAK,YAAY,MAAM,IAAI;AAAA,EACnC;AAAA,EAGA,MAAc,mBAAmB,UAA2B;AAExD,SAAK,WAAW;AAEhB,aAAQ,WAAW,UAAS;AACxB,UAAI,MAAM,MAAM,KAAK,eAAe,OAAO;AAC3C,UAAG,CAAC;AACA,gBAAQ,MAAM,sCAAsC,QAAQ,IAAI;AAAA;AAEhE,oBAAI,UAAU,KAAK,EAAE,+BAA+B,QAAQ,IAAI,EAAE;AAAA,IAC1E;AACA,SAAK,oBAAoB;AACzB,WAAO;AAAA,EACX;AAAA,EAEA,MAAa,eAAe,EAAE,MAAM,MAAM,KAAK,GAAkB;AAI7D,QAAG,CAAC,QAAQ,CAAC;AACT,YAAM,IAAI,MAAM,yCAAyC;AAE7D,QAAG,KAAK,YAAY;AAChB,YAAM,IAAI,MAAM,8BAA8B;AAClD,WAAO,MAAM,KAAK,QAAQ,QAAQ,EAAC,MAAM,MAAM,KAAI,CAAC;AAAA,EACxD;AAAA,EAEA,MAAc,cAAa;AAEvB,QAAI,MAAM,MAAM,KAAK,KAAK,OAAO;AACjC,QAAG,QAAQ,QAAS,MAAK,kBAAkB;AAC3C,WAAO;AAAA,EACX;AAAA,EAEA,MAAc,cAAa;AAEvB,eAAW,YAAY;AAEnB,UAAG,KAAK,QAAQ,UAAU,MAAM;AAC5B,cAAM,KAAK,WAAW,EAAE,QAAQ,YAAY,WAAW,KAAK,CAAC;AAEjE,UAAG,KAAK,YAAY,OAAW,MAAK,QAAQ,MAAM;AAElD,cAAQ,KAAK,CAAC;AAAA,IAClB,GAAG,GAAI;AACP,WAAO;AAAA,EACX;AAAA,EAEO,eAAc;AACjB,QAAG,KAAK,YAAY,OAAW,OAAM,IAAI,MAAM,8BAA8B;AAC7E,QAAG,KAAK,OAAO,OAAW,OAAM,IAAI,MAAM,yBAAyB;AACnE,QAAI,YAAY,CAAC;AACjB,QAAI,aAAqC;AACzC,QAAG,KAAK,SAAS,UAAS;AACtB,mBAAa,KAAK,QAAQ,QAAQ,KAAK,EAAE;AACzC,kBAAY,WAAW,aAAa;AAAA,IACxC,WAAS,KAAK,SAAS,UAAS;AAC5B,mBAAa,KAAK,QAAQ,QAAQ,QAAQ;AAC1C,kBAAY,WAAW,aAAa;AACpC,UAAG,eAAe;AACd,cAAM,IAAI,MAAM,+CAA+C;AAAA,IACvE;AACA,WAAO;AAAA,EACX;AAAA,EAEO,QAAQ,QAAe;AAC1B,WAAO,KAAK,YAAY,MAAM,KAAK;AAAA,EACvC;AAWJ;AAGA,IAAO,eAAQ;;;ACvWf,IAAM,cAAN,MAAkB;AAAA,EAUd,YAAY,SAAkB;AAT9B,wBAAQ;AACR,wBAAQ;AAER;AAAA,wBAAQ,SAAoB,IAAI,aAAK;AACrC,wBAAQ;AACR,wBAAQ,WAAU,IAAI,gBAAQ,CAAC,CAAC;AAChC,wBAAQ;AAwNV,wBAAQ,WAAU,CAAC,WAAmB,KAAK,MAAM,OAAO,MAAM;AAE9D,wBAAQ,WAAU,CAAC,WAAmB,KAAK,MAAM,QAAQ,MAAM;AAG/D;AAAA,wBAAO,WAAU,KAAK;AACtB,wBAAO,cAAa,KAAK;AACzB,wBAAO,oBAAmB,KAAK;AA3NzB,SAAK,OAAO,QAAQ;AACpB,SAAK,UAAU;AACf,SAAK,UAAU,IAAI,gBAAQ,EAAE,MAAM,KAAK,OAAO,gBAAgB,CAAC;AAEhE,SAAK,QAAQ;AAAA,MACT,KAAK,OAAO;AAAA,MACZ,KAAK,QAAQ;AAAA,MACb,KAAK,QAAQ;AAAA,IACjB;AAEA,SAAK,QAAQ,iBAAiB,KAAK,cAAc,KAAK,IAAI,CAAC;AAE3D,SAAK,QAAQ,iBAAiB,KAAK,qBAAqB,KAAK,IAAI,CAAC;AAElE,SAAK,QAAQ,QAAQ,SAAS;AAAA,EACpC;AAAA,EAEQ,cAAc,YAAwB;AAE1C,gBAAI,oDAAoD;AAExD,QAAI,OAAO,IAAI,aAAK;AAEpB,SAAK,kBAAkB;AAAA,MACnB,KAAK,OAAO,QAAgB,MAAM,KAAK,OAAO,IAAI,GAAG;AAAA,MACrD,KAAK,OAAO,KAAa,UAAe,MAAM,KAAK,OAAO,IAAI,KAAK,KAAK;AAAA,IAC5E,CAAC;AAED,SAAK,kBAAkB,YAAY,KAAK,OAAO;AAE/C,SAAK,wBAAwB,KAAK,mBAAmB,KAAK,IAAI,CAAC;AAE/D,QAAI,KAAK,KAAK,MAAM;AACpB,QAAG,OAAO,OAAW,OAAM,IAAI,MAAM,sBAAsB;AAE3D,SAAK,MAAM,IAAI,IAAI,IAAI;AAEvB,SAAK,QAAQ,EAAE;AAAA,EACnB;AAAA,EAGQ,qBAAqB,YAAwB;AAEjD,QAAI,KAAK,WAAW,MAAM;AAC1B,QAAG,OAAO,OAAW,OAAM,IAAI,MAAM,sBAAsB;AAE3D,SAAK,MAAM,OAAO,EAAE;AAAA,EACxB;AAAA,EAEQ,mBAAmB,QAAgB,MAAY;AAGnD,QAAG,CAAC,OAAQ,OAAM,IAAI,MAAM,qBAAqB;AACjD,QAAI,KAAK,KAAK,MAAM;AACpB,QAAG,OAAO,OAAW,OAAM,IAAI,MAAM,sBAAsB;AAC3D,QAAG,KAAK,OAAO,KAAK,KAAK,QAAQ;AAC7B,WAAK,QAAQ,EAAE;AAAA,aACX,KAAK,OAAO;AAChB,WAAK,QAAQ,EAAE;AAAA;AAEf,YAAM,IAAI,MAAM,qBAAqB;AAAA,EAC7C;AAAA,EAEA,MAAa,QAAQ,UAAkB,IAAoB;AAEvD,QAAG,YAAY,IAAI;AACf,UAAIC,QAAO,KAAK,QAAQ,OAAO;AAE/B,YAAM,uBAAe,MAAMA,MAAK,OAAO,GAAG,KAAK,KAAK,KAAK,GAAI,EAAE,MAAM,MAAM;AACvE,cAAM,IAAI,MAAM,6BAA6B,OAAO,cAAc;AAAA,MACtE,CAAC;AACD,aAAOA;AAAA,IACX;AAEA,QAAG,KAAK,MAAM,QAAQ;AAClB,kBAAI,yCAAyC;AAGjD,UAAM,uBAAe,MAAM,KAAK,MAAM,WAAW,GAAG,CAAC,EACpD,MAAM,MAAM;AAAE,YAAM,IAAI,MAAM,2CAA2C;AAAA,IAAE,CAAC;AAG7E,QAAI,OAAO,KAAK,MAAM,IAAI;AAC1B,QAAG,SAAS,KAAM,OAAM,IAAI,MAAM,cAAc;AAEhD,WAAO;AAAA,EACX;AAAA,EAEO,UAAS;AAEZ,WAAO,KAAK,MAAM,YAAY,EAAE,IAAI;AAAA,EACxC;AAAA,EAEO,eAAwB;AAE3B,WAAO,KAAK,MAAM,kBAAkB;AAAA,EACxC;AAAA,EAEO,eAAwB;AAE3B,WAAO,KAAK,MAAM,mBAAmB;AAAA,EACzC;AAAA,EAEA,MAAa,QAAQ,UAAgC;AACjD,QAAI,QAAQ,KAAK,MAAM,QAAQ;AAE/B,QAAI,WAAW,MAAM,IAAI,OAAO,SAAe;AAC3C,UAAG,KAAK,OAAO,EAAG,OAAM,KAAK,SAAS;AACtC,aAAO,SAAS,IAAI;AAAA,IACxB,CAAC;AAED,WAAO,QAAQ,IAAI,QAAQ;AAAA,EAC/B;AAAA,EAEA,MAAa,iBAAiB,UAA4B;AAEtD,WAAO,KAAK;AAAA,MACR,OAAO,SAAe,MAAM,KAAK,iBAAiB,QAAQ;AAAA,IAC9D;AAAA,EACJ;AAAA,EAEA,MAAa,WAAW,OAAe,IAAI,QAAgB,GAAG,WAAgB,CAAC,GAAG;AAE9E,QAAG,SAAS,GAAI,QAAO,UAAU,KAAK;AACtC,gBAAI,4CAA4C,MAAM,KAAK;AAC3D,SAAK,QAAQ,MAAM,MAAM;AAAA,MACrB,gBAAgB;AAAA,MAChB;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EAEA,MAAa,SAAS,SAAiB,IAAI;AAEvC,QAAG,KAAK,MAAM,QAAQ;AAClB,aAAO;AAEX,QAAI,OAAQ,WAAW,KACnB,KAAK,MAAM,UAAU,IACrB,KAAK,MAAM,OAAO,MAAM;AAC5B,QAAG,SAAS,QAAQ,SAAS;AACzB,YAAM,IAAI,MAAM,4CAA4C;AAEhE,UAAM,KAAK,KAAK;AAAA,EACpB;AAAA,EAEA,MAAa,UAAU,UAAkB,CAAC,GAAG;AAEzC,aAAQ,UAAU;AACd,YAAM,KAAK,SAAS,MAAM;AAAA,EAClC;AAAA,EAEO,eAAc;AAEnB,WAAO,KAAK,MAAM,gBAAgB;AAAA,EACpC;AAAA,EAEO,eAAc;AAEnB,WAAO,KAAK,MAAM,iBAAiB;AAAA,EACrC;AAAA,EAEO,WAAW;AAEd,WAAO,KAAK,MAAM,QAAQ;AAAA,EAC9B;AAAA,EAEO,WAAW;AACd,WAAO,KAAK,MAAM,KAAK;AAAA,EAC3B;AAAA,EAEO,eAAe;AACpB,WAAO,KAAK,MAAM,KAAK;AAAA,EACzB;AAAA,EAEO,QAAQ,QAAgB;AAE3B,QAAI,OAAO,KAAK,MAAM,IAAI,MAAM;AAChC,QAAG,SAAS,KAAM,OAAM,IAAI,MAAM,wCAAwC,MAAM,YAAY;AAC5F,WAAO;AAAA,EACX;AAAA,EAEO,eAAe;AAClB,QAAG,KAAK,YAAY,OAAW,OAAM,IAAI,MAAM,sBAAsB;AACrE,WAAO,KAAK,QAAQ,uBAAuB;AAAA,EAC/C;AAAA,EAEA,MAAa,uBAAuB,OAAe;AAC/C,QAAI,UAAU;AACd,UAAM,uBAAe,MAAM,KAAK,MAAM,KAAK,KAAK,OAAO,OAAO,EAC7D,MAAM,MAAM;AAAE,YAAM,IAAI,MAAM,cAAc,OAAO,sCAAsC;AAAA,IAAE,CAAC;AAC7F,WAAO;AAAA,EACX;AAAA,EAGA,MAAa,OAAO;AAEhB,WAAO,KAAK;AAAA,MACR,OAAO,SAAe,MAAM,KAAK,KAAK;AAAA,IAC1C;AAAA,EACJ;AAAA,EAEA,MAAc,UAAU,UAA+B;AAEnD,QAAI,QAAQ,KAAK,MAAM,QAAQ;AAE/B,QAAI,WAAW,MAAM;AAAA,MACjB,OAAO,SAAe,MAAM,SAAS,IAAI;AAAA,IAC7C;AAEA,WAAO,QAAQ,IAAI,QAAQ;AAAA,EAC/B;AAWF;AAEA,IAAO,sBAAQ;;;AC1Qf,IAAO,gBAAQ;;;ACAf,IAAM,eAAN,MAAmB;AAAA;AAAA,EAiBf,YAAY,EAAE,iBAAiB,UAAU,GAAuD;AAThG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAQ,SAAwB,IAAI,cAAM;AAC1C,wBAAQ;AACR,wBAAQ;AACR,wBAAQ,aAAqB;AAC7B,wBAAQ;AACR,wBAAQ,aAAY;AACpB;AAAA,wBAAQ,kBAA2B,CAAC;AACpC;AAAA,wBAAQ,wBAAuB;AAS3B,SAAK,kBAAkB;AACvB,SAAK,YAAY;AACjB,QAAI,CAAC,KAAK,gBAAiB,OAAM,IAAI,MAAM,gCAAgC;AAC3E,QAAI,CAAC,KAAK,UAAW,OAAM,IAAI,MAAM,0BAA0B;AAE/D,SAAK,WAAW,YAAY,YAAY;AAEpC,UAAI,KAAK,UAAW;AAEpB,UAAI,KAAK,MAAM,KAAK,MAAM,GAAG;AACzB,aAAK,YAAY;AACjB;AAAA,MACJ;AAEA,WAAK,YAAY;AAEjB,UAAI,UAAU,KAAK,MAAM,IAAI;AAC7B,UAAG,YAAY,MAAO,OAAM,IAAI,MAAM,gDAAgD;AAEtF,YAAM,QAAQ,MAAM,KAAK,UAAU,QAAQ,QAAQ;AAEnD,UAAI,YAAY,KAAK,IAAI;AACzB,UAAI;AAEJ,WAAK,YAAY;AAEjB,WAAK,gBAAgB,OAAO,OAAO,EAAE;AAAA,QACjC,CAACC,YAAgB;AACb,cAAG,CAAC,QAAS,OAAM,IAAI,MAAM,iDAAiD;AAC9E,oBAAU,KAAK,IAAI;AAEnB,kBAAQ,YAAY;AACpB,kBAAQ,SAASA;AAEjB,gBAAM,YAAY,UAAU;AAE5B,eAAK,eAAe,KAAK,SAAS;AAElC,cAAI,KAAK,eAAe,SAAS,KAAK;AAClC,iBAAK,eAAe,MAAM;AAAA,QAClC;AAAA,MACJ,EAAE,MAAM,CAAC,QAAc;AACnB,gBAAQ,MAAM,2CAA2C;AACzD,gBAAQ,MAAM,GAAG;AACjB,eAAO;AAAA,MACX,CAAC;AAAA,IACL,GAAG,GAAG;AAAA,EACV;AAAA,EAEO,WAAW,SAAgC;AAG9C,WAAO,IAAI,QAAQ,OAAO,SAAS,WAAW;AAC1C,WAAK,MAAM,KAAK,OAAO;AAEvB,YAAM,uBAAe,MAAM;AACvB,oBAAI,OAAO;AACX,eAAO,QAAQ,cAAc;AAAA,MACjC,GAAG,KAAK,KAAK,KAAM,KAAK,SAAS,EAChC,MAAM,SAAO;AACV,gBAAQ,MAAM,2CAA2C;AACzD,gBAAQ,MAAM,GAAG;AACjB,eAAO,GAAG;AAAA,MACd,CAAC;AAED,cAAQ,QAAQ,MAAM;AAAA,IAC1B,CAAC;AAAA,EACL;AAAA,EAEO,YAAqB;AACxB,WAAO,KAAK,MAAM,KAAK;AAAA,EAC3B;AAAA,EAEO,mBAA2B;AAC9B,QAAI,KAAK,eAAe,WAAW,EAAG,QAAO;AAC7C,UAAM,MAAM,KAAK,eAAe,OAAO,CAAC,KAAK,SAAS,MAAM,MAAM,CAAC;AACnE,WAAO,MAAM,KAAK,eAAe;AAAA,EACrC;AAAA,EAEO,OAAO;AACV,SAAK,MAAM,MAAM;AACjB,kBAAc,KAAK,QAAQ;AAAA,EAE/B;AACJ;AAEA,IAAO,uBAAQ;;;ACjHf,gBAAe;AAmBf,IAAM,kBAAN,MAAsB;AAAA,EAelB,YAAY,QAAwB;AAdpC,wBAAQ,iBAAwB;AAChC,wBAAQ;AACR,wBAAQ;AACR,wBAAQ;AACR,wBAAQ;AACR,wBAAQ;AACR,wBAAQ;AACR,wBAAQ;AACR,wBAAQ;AACR,wBAAQ;AACR,wBAAQ;AACR,wBAAQ;AACR,wBAAQ;AAIJ,SAAK,wBAAwB,OAAO,yBAAyB;AAE7D,SAAK,0BAA0B,OAAO,2BAA2B;AAEjE,SAAK,eAAe,OAAO,gBAAgB;AAC3C,SAAK,eAAe,OAAO,gBAAgB;AAE3C,SAAK,uBAAuB,OAAO,wBAAwB;AAE3D,SAAK,uBAAuB,OAAO,wBAAwB;AAE3D,SAAK,gBAAgB,OAAO,iBAAiB;AAE7C,SAAK,iBAAiB,OAAO;AAC7B,SAAK,cAAc,OAAO;AAC1B,SAAK,WAAW,OAAO;AACvB,SAAK,cAAc,OAAO;AAE1B,SAAK,uBAAuB;AAE5B,SAAK,WAAW,KAAK,gBAAgB;AAAA,EACzC;AAAA,EAEQ,cAAsB;AAC1B,QAAI,OAAO,UAAAC,QAAG,KAAK;AACnB,QAAI,YAAY,KAAK,OAAO,CAAC,KAAK,QAAQ;AACtC,UAAI,QAAQ,OAAO,OAAO,IAAI,KAAK,EAAE,OAAO,CAAC,GAAG,MAAM,IAAI,GAAG,CAAC;AAC9D,aAAO,MAAO,IAAI,MAAM,OAAO,QAAS;AAAA,IAC5C,GAAG,CAAC;AACJ,WAAO,YAAY,KAAK;AAAA,EAC5B;AAAA,EAEQ,iBAAyB;AAC7B,YAAS,UAAAA,QAAG,SAAS,IAAI,UAAAA,QAAG,QAAQ,KAAK,UAAAA,QAAG,SAAS,IAAK;AAAA,EAC9D;AAAA,EAEQ,gBAAsB;AAC1B,QAAG,KAAK,mBAAmB,OAAW,OAAM,MAAM,6BAA6B;AAC/E,QAAG,KAAK,gBAAgB,OAAW,OAAM,MAAM,0BAA0B;AAEzE,SAAK,uBAAuB;AAC5B,UAAM,YAAY,KAAK,eAAe;AACtC,UAAM,EAAE,WAAW,aAAa,IAAI,KAAK,YAAY;AACrD,QAAG,cAAc,UAAa,iBAAiB;AAC3C,YAAM,IAAI,MAAM,iFAAiF;AACrG,UAAM,WAAW,YAAY,eAAe;AAC5C,UAAM,cAAc,YAAY,KAAK;AACrC,SAAK,gBAAgB;AACrB,UAAM,SAAS,KAAK,YAAY;AAChC,UAAM,SAAS,KAAK,eAAe;AAehC;AAAA;AAAA,MAEI,YAAY,KAAK;AAAA,MAEjB,cAAc;AAAA,MAEd,SAAS,KAAK,gBACd,SAAS,KAAK;AAAA,MAEd,WAAW,KAAK;AAAA,MACnB;AACG,kBAAI,2BAA2B;AAE/B,WAAK,SAAS;AAAA,IAClB;AACA;AAAA;AAAA,MACI,aAAa,KAAK;AAAA,MAElB,YAAY;AAAA,MAEZ,eAAe;AAAA,MAEf,WAAW,KAAK;AAAA,MAChB;AACG,kBAAI,+BAA+B;AAEnC,WAAK,YAAY;AAAA,IACrB;AAAA,EACV;AAAA,EAEQ,kBAAkC;AACtC,WAAO,YAAY,MAAM;AACrB,WAAK,cAAc;AAAA,IACvB,GAAG,KAAK,aAAa;AAAA,EACzB;AAAA,EAEQ,yBAA+B;AACnC,QAAI,KAAK,mBAAmB;AACxB,YAAM,IAAI,MAAM,oDAAoD;AACxE,QAAI,KAAK,gBAAgB;AACrB,YAAM,IAAI,MAAM,iDAAiD;AACrE,QAAI,KAAK,aAAa;AAClB,YAAM,IAAI,MAAM,8CAA8C;AAClE,QAAI,KAAK,gBAAgB;AACrB,YAAM,IAAI,MAAM,iDAAiD;AAAA,EACzE;AAAA,EAEO,OAAa;AAEhB,kBAAc,KAAK,QAAQ;AAAA,EAC/B;AACJ;AAEA,IAAO,0BAAQ;;;ACxJf,IAAAC,0BAAiC;AASjC,IAAM,gBAAN,MAAM,eAAc;AAAA;AAAA,EAYhB,YAAY,MAAc,SAAkB,UAAmB,CAAC,GAAG,WAAiB;AAPpF;AAAA;AAAA;AAAA;AAAA,wBAAO;AACP,wBAAO;AACP,wBAAO;AAEP;AAAA,wBAAO,aAAsB,CAAC;AAC9B,wBAAQ,aAAwB,CAAC;AAG7B,SAAK,OAAO;AACZ,SAAK,UAAU;AACf,QAAG,QAAQ,eAAe,OAAW,SAAQ,aAAa;AAC1D,SAAK,UAAU;AACf,SAAK,YAAY,aAAa,CAAC;AAE/B,QAAI,aAAa,KAAK,QAAQ,WAAW,IAAI;AAC7C,QAAG,eAAe,KAAM,OAAM,IAAI,MAAM,WAAW,IAAI,YAAY;AAEnE,SAAK,YAAY,WAAW;AAE5B,QAAG,KAAK,UAAU,WAAW,GAAG;AAE5B,WAAK,UAAU,QAAQ,CAAC,aAAuB;AAC3C,QAAC,KAAa,SAAS,KAAK,IACxB,OAAO,eAAoB,MAAM,KAAK,YAAY,SAAS,OAAO,EAAE,WAAW,CAAC;AAAA,MACxF,CAAC;AAAA,IACL,OAAK;AAED,WAAK,UAAU,QAAQ,CAAC,aAAuB;AAC3C,QAAC,KAAa,SAAS,KAAK;AAAA,QAExB,OAAO,eAAoB;AAC3B,cAAI,UAAU,MAAM,QAAQ;AAAA,YACxB,KAAK,UAAU;AAAA,cACX,OAAO,WAAmB,MAAM,KAAK;AAAA,gBACjC,SAAS;AAAA,gBAAO,EAAE,YAAY,WAAW,OAAO;AAAA,cACpD;AAAA,YACJ;AAAA,UACJ;AAEA,cAAG,QAAQ,WAAW,EAAG,QAAO,QAAQ,CAAC;AAAA,cACpC,QAAO;AAAA,QAChB;AAAA,MACJ,CAAC;AAAA,IACL;AAAA,EACJ;AAAA,EAEA,MAAc,YAAY,OAAe,MAAW;AAEhD,QAAI,aAAa,KAAK,QAAQ,WAAW,KAAK,IAAI;AAElD,QAAI,eAAe,KAAM,OAAM,IAAI,MAAM,WAAW,KAAK,IAAI,YAAY;AACzE,QAAI,WAAW,MAAM,WAAW,KAAK,OAAO,IAAI;AAEhD,QAAI,SAAS,YAAY;AACrB,aAAO,KAAK,aAAa,SAAS,KAAK;AAC3C,WAAO,SAAS;AAAA,EACpB;AAAA;AAAA;AAAA,EAKA,MAAa,OAAO,KAAsB;AAEtC,QAAG,QAAQ,OAAW,OAAM;AAC5B,QAAG,QAAQ,MAAO,OAAM;AAExB,QAAI,YAAY,MAAM,KAAK,YAAY,WAAW,EAAE,YAAY,IAAI,CAAC;AAErE,QAAG,cAAc,KAAM;AAEvB,WAAO,IAAI,eAAc,KAAK,MAAM,KAAK,SAAS,KAAK,SAAS,SAAS;AAAA,EAC7E;AAAA,EAEA,MAAa,KAAKC,OAAc;AAE5B,QAAG,KAAK,UAAU,WAAW,GAAG;AAC5B,aAAO,MAAM,KAAK,YAAY,SAAS,EAAE,YAAYA,MAAK,SAAS,EAAE,CAAC;AAAA,IAC1E,OAAO;AAEJ,UAAI,UAAU,MAAM,QAAQ;AAAA,QACvB,KAAK,UAAU;AAAA,UACX,OAAO,WAAmB,MAAM,KAAK;AAAA,YACjC;AAAA,YAAS,EAAE,YAAYA,MAAK,SAAS,GAAG,WAAW,OAAO;AAAA,UAC9D;AAAA,QACJ;AAAA,MACJ;AAEA,UAAG,QAAQ,WAAW,EAAG,QAAO,QAAQ,CAAC;AAAA,UACpC,QAAO;AAAA,IAChB;AAAA,EACJ;AAAA,EAGA,MAAa,YAAYA,OAAc;AAEnC,WAAO,MAAM,KAAK,YAAY,gBAAgB,EAAE,YAAYA,MAAK,SAAS,EAAE,CAAC;AAAA,EACjF;AAAA,EAEQ,aAAa,WAAkB;AAEnC,QAAI,YAAQ,0CAAiB,SAAS;AACtC,QAAI,KAAK,QAAQ,WAAY,OAAM;AACnC,QAAI,KAAK,QAAQ,SAAU,SAAQ,MAAM,KAAK;AAC9C,QAAI,KAAK,QAAQ,YAAa,QAAO;AAAA,QAChC,QAAO;AAAA,EAChB;AAEJ;AAEA,IAAO,wBAAQ;;;AC1Hf,IAAM,QAAN,MAAY;AAAA,EAAZ;AACI,wBAAQ,SAAgC,oBAAI,IAAI;AAChD,wBAAQ,SAAuB,QAAQ,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA,EAKvC,qBAAqB,OAAwB;AAEjD,QAAI;AACA,WAAK,UAAU,KAAK;AAAA,IACxB,SAAS,KAAK;AACV,YAAM,IAAI,MAAM,kCAAkC;AAAA,IACtD;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,SAAYC,KAAkC;AACxD,QAAI;AACJ,UAAM,OAAO,IAAI,QAAc,aAAY,UAAU,OAAQ;AAE7D,UAAM,OAAO,KAAK;AAClB,SAAK,QAAQ;AAEb,UAAM;AACN,QAAI;AACA,aAAO,MAAMA,IAAG;AAAA,IACpB,UAAE;AACE,cAAS;AAAA,IACb;AAAA,EACJ;AAAA,EAEA,MAAM,IAAI,KAAa,OAAiC;AAEpD,QAAG,UAAU,UAAa,UAAU,MAAM;AACtC,cAAQ;AACR,YAAM;AAAA,IACV;AAEA,WAAO,KAAK,SAAS,YAAY;AAC7B,WAAK,MAAM,IAAI,KAAK,KAAK;AAAA,IAC7B,CAAC;AAAA,EACL;AAAA,EAEA,MAAM,IAAmB,KAAqC;AAC1D,QAAG,QAAQ,UAAa,QAAQ,QAAQ,QAAQ;AAC5C,YAAM;AACV,WAAO,KAAK,SAAS,YAAY;AAC7B,aAAO,KAAK,MAAM,IAAI,GAAG;AAAA,IAC7B,CAAC;AAAA,EACL;AAAA,EAEA,MAAM,OAAO,KAA4B;AACrC,QAAG,QAAQ,UAAa,QAAQ,QAAQ,QAAQ;AAC5C,YAAM;AACV,WAAO,KAAK,SAAS,YAAY;AAC7B,WAAK,MAAM,OAAO,GAAG;AAAA,IACzB,CAAC;AAAA,EACL;AAAA,EAEA,MAAM,QAAuB;AACzB,WAAO,KAAK,SAAS,YAAY;AAC7B,WAAK,MAAM,MAAM;AAAA,IACrB,CAAC;AAAA,EACL;AAAA,EAEA,MAAM,IAAI,KAA+B;AACrC,QAAG,QAAQ,UAAa,QAAQ,QAAQ,QAAQ;AAC5C,YAAM;AACV,WAAO,KAAK,SAAS,YAAY;AAC7B,aAAO,KAAK,MAAM,IAAI,GAAG;AAAA,IAC7B,CAAC;AAAA,EACL;AAAA,EAEA,MAAM,OAA0B;AAC5B,WAAO,KAAK,SAAS,YAAY;AAC7B,aAAO,MAAM,KAAK,KAAK,MAAM,KAAK,CAAC;AAAA,IACvC,CAAC;AAAA,EACL;AACJ;AAEA,IAAO,gBAAQ;;;AC3Ef,IAAAC,0BAA+B;AAkB/B,IAAM,UAAN,MAAc;AAAA,EAsBV,YAAY,QAAoB;AApBhC;AAAA,wBAAO;AACP,wBAAO;AACP,wBAAO;AACP,wBAAQ;AACR,wBAAQ,SAAe,IAAI,cAAM;AACjC,wBAAQ,mBAA2C;AACnD,wBAAQ,gBAAoC;AAC5C,wBAAO;AACP,wBAAO;AACP,wBAAO;AACP,wBAAQ;AACR,wBAAQ;AACR,wBAAQ;AACR,wBAAQ;AACR,wBAAQ;AACR,wBAAQ;AACR,wBAAQ;AACR,wBAAQ;AACR,wBAAQ,qBAA6B;AAmXrC,wBAAO,OAAM,OAAO,KAAU,QAAa,SACvC,MAAM,KAAK,MAAM,IAAI,KAAK,KAAK;AAEnC,wBAAO,OAAM,OAAO,MAAc,OAC9B,MAAM,KAAK,MAAM,IAAI,GAAG;AApXxB,SAAK,OAAO,OAAO;AAEnB,SAAK,OAAO,OAAO,SAAS,QAAQ;AACpC,SAAK,OAAO,QAAQ,SAAS,QAAQ;AAErC,SAAK,UAAU,OAAO,SAAS,WAAW;AAC1C,SAAK,UAAU,OAAO,SAAS,WAAW;AAE1C,SAAK,iBAAiB,OAAO,kBAAkB;AAE/C,SAAK,eAAe,OAAO,gBAAgB,CAAC;AAE5C,SAAK,gBAAgB,OAAO,yBAAyB,CAAC;AAEtD,SAAK,uBAAuB,OAAO,wBAAwB;AAC3D,SAAK,gBAAgB;AAGrB,QAAG,KAAK,kBAAkB,UAAa,KAAK,yBAAyB;AACjE,YAAM,IAAI,MAAM,kEAAkE;AAEtF,SAAK,UAAU,OAAO,WAAW,CAAC;AAGlC,QAAG,KAAK,QAAQ,oBAAoB,QAAU;AAC1C,WAAK,kBAAkB;AACvB,UAAG,KAAK,QAAQ,eAAe;AAC3B,aAAK,QAAQ,aAAa;AAAA,IAClC,OAAK;AACD,WAAK,kBAAkB,KAAK,QAAQ;AACpC,UAAG,KAAK,QAAQ,eAAe;AAC3B,aAAK,QAAQ,aAAa;AAAA,IAClC;AAAA,EACJ;AAAA,EAEA,MAAa,QAAQ;AAEjB,SAAK,UAAU,IAAI,gBAAQ,KAAK,OAAO;AAEvC,SAAK,QAAQ,MAAM,YAAY,KAAK,MAAM;AAAA,MACtC,gBAAgB;AAAA;AAAA,MAChB,sBAAsB;AAAA;AAAA,IAC1B,CAAC;AAED,QAAG,KAAK,QAAQ,GAAG,YAAY,KAAK,IAAI,GAAG;AAEvC,YAAM,KAAK,kBAAkB;AAAA,IACjC;AAEA,QAAG,KAAK,QAAQ,GAAG,WAAW,KAAK,IAAI,GAAG;AACtC,YAAM,KAAK,kBAAkB;AAAA,IACjC;AAAA,EACJ;AAAA,EAEA,MAAc,oBAAoB;AAG9B,QAAG,KAAK,SAAS,EAAG,MAAK,OAAO,UAAM,gBAAAC,SAAQ,EAAC,MAAM,KAAK,KAAI,CAAC;AAE/D,QAAG,KAAK,yBAAyB,OAAW,OAAM,KAAK,sBAAsB;AAC7E,gBAAI,kBAAkB,KAAK,aAAa;AAExC,UAAM,KAAK,sBAAsB;AAEjC,SAAK,yBAAyB;AAE9B,SAAK,UAAU,IAAI,gBAAQ,EAAC,MAAM,KAAK,OAAO,mBAAkB,CAAC;AAEjE,QAAI,YAAY,oBAAY,KAAK,YAAY,EAAE;AAAA;AAAA,MAE3C,QAAM,EAAE,GAAG,GAAG,UAAU,KAAK,eAAe,GAAG,KAAK,EAAE;AAAA,IAC1D;AAGA,QAAI,gBAA2B,EAAE,OAAO,SAAS,UAAU,MAAI;AAAA,IAAC,EAAE;AAClE,cAAU,KAAK,EAAE,GAAG,eAAe,UAAU,KAAK,eAAe,eAAe,MAAM,EAAE,CAAC;AAEzF,gBAAY,UAAU,OAAO,KAAK,oBAAoB,CAAC;AAEvD,SAAK,QAAQ,aAAa,KAAK,MAAM,KAAK,MAAM,KAAK,MAAM,SAAS;AAEpE,SAAK,4BAA4B;AAEjC,SAAK,gBAAgB,KAAK,cAAc,OAAO,CAAC,MAAsB,EAAE,SAAS,KAAK,IAAI;AAE1F,QAAI,cAAc,MAAM,KAAK,QAAQ,WAAW,KAAK,aAAa;AAElE,QAAI,WAAW,YAAY,IAAK,CAAC,MAAkB;AAC/C,UAAI,OAAO,EAAE,cAAc;AAC3B,UAAG,SAAS,OAAW,OAAM,IAAI,MAAM,2BAA2B;AAClE,aAAO,IAAI,sBAAc,MAAM,KAAK,SAAoB,KAAK,OAAO;AAAA,IACxE,CAAC,EAAE,OAAO,CAAC,KAAU,MAAqB;AACtC,UAAI,EAAE,IAAI,IAAI;AACd,aAAO;AAAA,IACX,GAAG,CAAC,CAAC;AAEL,SAAK,oBAAoB;AAEzB,QAAG,KAAK,mBAAmB;AACvB,WAAK,eAAe,EAAE,GAAG,UAAU,QAAQ,KAAK,OAAO,QAAQ,MAAM,MAAM,KAAK,CAAC;AAAA,EACzF;AAAA,EAEA,MAAc,oBAAoB;AAC9B,QAAI,OAAO,IAAI,cAAK;AAKpB,QAAI,WAAW,QAAQ,IAAI;AAC3B,QAAG,aAAa;AACZ,YAAM,IAAI,MAAM,wEAAwE;AAC5F,QAAI,EAAE,MAAM,KAAK,IAAI,KAAK,MAAM,QAAQ,EAAE,UAAU;AAEpD,UAAM,KAAK,gBAAgB,MAAM,IAAI;AAErC,UAAM,KAAK,YAAY,KAAK,aAAa;AAEzC,SAAK,WAAW,KAAK,YAAY;AAEjC,UAAM,KAAK,SAAS;AAAA,EACxB;AAAA,EAEA,MAAc,wBAAwB;AAGlC,QAAG,OAAO,KAAK,KAAK,YAAY,EAAE,WAAW,EAAG,QAAO;AAEvD,QAAG,KAAK,YAAY;AAChB,WAAK,UAAU,UAAM,gBAAAA,SAAQ,EAAC,MAAM,KAAK,QAAO,CAAC;AAErD,SAAK,QAAQ,IAAI,oBAAY;AAAA,MACzB,MAAM,KAAK;AAAA,MACX,MAAM,KAAK;AAAA,MACX,MAAM,KAAK;AAAA,MACX,OAAO,KAAK;AAAA;AAAA,IAChB,CAAC;AAED,UAAM,KAAK,MAAM,WAAW,WAAW,KAAK,MAAM,KAAK,iBAAiB;AAAA,MACpE,UAAU,EAAE,MAAM,KAAK,SAAS,MAAM,KAAK,QAAQ;AAAA,IACvD,CAAC;AAED,UAAM,KAAK,MAAM,iBAAiB,KAAK,aAAa;AAEpD,WAAO,KAAK;AAAA,EAChB;AAAA,EAEQ,2BAA2B;AAG/B,QAAG,OAAO,KAAK,KAAK,YAAY,EAAE,WAAW,EAAG,QAAO;AAEnD,QAAG,KAAK,UAAU,OAAW,OAAM,IAAI,MAAM,6BAA6B;AAE1E,SAAK,eAAe,IAAI,qBAAa;AAAA;AAAA,MAEjC,WAAW,KAAK,MAAM,QAAQ,KAAK,KAAK,KAAK;AAAA,MAC7C,iBACI,OAAO,MAAY,YAAqB,MAAM,KAAK,QAAQ,IAAI,EAAE,QAAQ,QAAQ,QAAQ,UAAU;AAAA,IAE3G,CAAC;AAAA,EACT;AAAA,EAEQ,8BAA8B;AAElC,QAAG,OAAO,KAAK,KAAK,YAAY,EAAE,WAAW,EAAG,QAAO;AAEvD,QAAG,KAAK,QAAQ,eAAe,MAAK;AAChC,WAAK,kBAAkB,IAAI,wBAAgB;AAAA;AAAA,QAEvC,gBAAgB,KAAK,cAAc,UAAU,KAAK,KAAK,YAAY;AAAA,QACnE,aAAa,OAAO,EAAE,WAAW,KAAK,OAAO,aAAa,GAAG,cAAc,KAAK,OAAO,aAAa,EAAE;AAAA,QACtG,UAAU,MAAM,KAAK,OAAO,WAAY,WAAW,KAAK,MAAM,GAAG,EAAE,UAAU,EAAE,MAAM,KAAK,SAAS,MAAM,KAAK,QAAQ,EAAE,CAAC;AAAA,QACzH,aAAa,MAAM,KAAK,OAAO,SAAS;AAAA,MAC5C,CAAC;AAAA,IACL;AAAA,EACJ;AAAA,EAGQ,sBAAsB;AAG1B,QAAI,YAAY,CAAC;AAAA;AAAA,MAEb,OAAO;AAAA,MACP,UAAU,OAAO,EAAE,QAAQ,KAAK,OAAO,aAAa,EAAE;AAAA,IAC1D,GAAE;AAAA,MACE,OAAO;AAAA,MACP,UAAU,MAAM,KAAK,OAAO,SAAS,EAAE,IAAI,CAAC,OAAa,EAAE,QAAQ,EAAE,QAAQ,IAAI,EAAE,GAAG,EAAE;AAAA,IAC5F,GAAE;AAAA,MACE,OAAO;AAAA;AAAA,MACP,UAAU,OAAO,EAAE,QAAQ,KAAK,OAAO,aAAa,EAAE;AAAA,IAC1D,GAAE;AAAA,MACE,OAAO;AAAA;AAAA,MACP,UAAU,OAAM,EAAE,QAAQ,KAAK,OAAO,aAAa,EAAE;AAAA,IACzD,GAAE;AAAA,MACE,OAAO;AAAA,MACP,QAAQ,CAAC,UAAU;AAAA,MACnB,UAAU,OAAO,aAAqB,MAAM,KAAK,OAAO,uBAAuB,QAAQ;AAAA,IAC3F,GAAE;AAAA;AAAA,MACE,OAAO;AAAA,MACP,QAAQ,CAAC,UAAU;AAAA,MACnB,UAAU,OAAO,aAAqB;AAClC,YAAG,KAAK,UAAU,OAAW,OAAM,IAAI,MAAM,qBAAqB;AAElE,YAAI,QAAQ,KAAK,OAAO,aAAa;AACrC,YAAG,UAAU,OAAW,QAAO,EAAE,SAAS,MAAM,WAAO,wCAAe,IAAI,MAAM,qBAAqB,CAAC,EAAE;AAExG,YAAG,WAAW,MAAO,QAAO,EAAE,SAAS,MAAM,WAAO,wCAAe,IAAI,MAAM,kBAAkB,CAAC,EAAE;AAClG,YAAG,aAAa,EAAG,YAAW;AAE9B,YAAI,iBAAiB,CAAC;AACtB,iBAAQ,IAAI,GAAG,IAAI,UAAU,KAAI;AAC7B,cAAI,OAAO,KAAK,OAAO,SAAS;AAChC,cAAG,SAAS,KAAM,OAAM,IAAI,MAAM,oBAAoB;AACtD,yBAAe,KAAK,KAAK,EAAE;AAAA,QAC/B;AAEA,eAAO,EAAE,QAAQ,eAAe;AAAA,MACpC;AAAA,IACJ,GAAE;AAAA;AAAA,MACE,OAAO;AAAA,MACP,QAAQ,CAAC,iBAAiB;AAAA,MAC1B,UAAU,CAAC,qBACV,EAAE,QAAQ,KAAK,OAAO;AAAA,QACnB,WAAW,KAAK;AAAA,QAChB;AAAA,QACA,EAAE,UAAU,EAAE,MAAM,KAAK,SAAS,MAAM,KAAK,QAAQ,EAAE;AAAA,MAC3D,EAAE;AAAA,IACN,GAAE;AAAA;AAAA,MACE,OAAO;AAAA,MACP,QAAQ,CAAC,SAAS;AAAA,MAClB,UAAU,OAAM,aAAqD;AACjE,YAAI;AACJ,YAAG,aAAa,QAAU;AACtB,gBAAM,MAAM,KAAK,OAAO,SAAS;AAAA,QACrC,WAAS,OAAO,aAAa,UAAS;AAClC,gBAAM,MAAM,KAAK,OAAO,SAAS,QAAQ;AAAA,QAC7C,WAAS,OAAO,aAAa,UAAS;AAClC,mBAAQ,IAAI,GAAG,IAAI,UAAU,IAAK,OAAM,KAAK,OAAO,SAAS;AAAA,QACjE,WAAS,SAAS,WAAW,GAAE;AAC3B,gBAAM,MAAM,KAAK,OAAO,SAAS;AAAA,QACrC,WAAS,SAAS,UAAU,GAAE;AAC1B,gBAAM,MAAM,KAAK,OAAO,UAAU,QAAQ;AAAA,QAC9C,OAAM;AACF,iBAAO,EAAE,SAAS,MAAM,WAAO,wCAAe,IAAI,MAAM,iBAAiB,CAAC,EAAE;AAAA,QAChF;AACA,eAAQ,EAAC,QAAQ,IAAG;AAAA,MACxB;AAAA,IACJ,GAAE;AAAA;AAAA,MACE,OAAO;AAAA,MACP,UAAU,OAAO,EAAE,QAAQ,KAAK,cAAc,UAAU,EAAE;AAAA,IAC9D,GAAE;AAAA,MACE,OAAO;AAAA,MACP,UAAU,OAAO,EAAE,QAAQ,KAAK,cAAc,iBAAiB,EAAE;AAAA,IACrE,GAAE;AAAA,MACE,OAAO;AAAA,MACP,QAAQ,CAAC,aAAa;AAAA,MACtB,UAAU,OAAO,gBAAqB;AAElC,YAAG,OAAO,gBAAgB;AACtB,iBAAO,EAAE,SAAS,MAAM,WAAO,wCAAe,IAAI,MAAM,6BAA6B,CAAC,EAAE;AAE5F,cAAM,uBAAe,MAAM,KAAK,mBAAmB,GAAK,EAAE,MAAM,MAAM;AAClE,gBAAM,IAAI,MAAM,6CAA6C;AAAA,QACjE,CAAC;AACD,YAAI,UAAU,KAAK,YAAY;AAC/B,YAAI,YAAY,EAAE,GAAG,SAAS,QAAQ,MAAM,MAAM,KAAK;AACvD,YAAI;AAEA,cAAIC,UAAS,MAAM,sBAAc,aAAa,SAAS;AACvD,iBAAO,EAAE,QAAQA,QAAO;AAAA,QAC5B,SAAQ,GAAI;AACR,iBAAO,EAAE,SAAS,MAAM,WAAO,wCAAe,CAAC,EAAE;AAAA,QACrD;AAAA,MACJ;AAAA,IACJ,GAAE;AAAA,MACE,OAAO;AAAA,MACP,QAAQ,CAAC,iBAAiB;AAAA,MAC1B,UAAU,OAAO,oBAAoC;AACjD,YAAG,KAAK,YAAY,OAAW,OAAM,IAAI,MAAM,wBAAwB;AACvE,cAAM,KAAK,SAAS,QAAQ,eAAe;AAAA,MAC/C;AAAA,IACJ,GAAE;AAAA,MACE,OAAO;AAAA,MACP,UAAU,OAAO,EAAE,QAAQ,KAAK,KAAK,EAAE;AAAA,IAC3C,CAAC;AAED,WAAO,UAAU,IAAI,OAAK;AACtB,aAAO,EAAE,GAAG,GAAG,UAAU,CAAC,EAAE,WAAW,MAAW,EAAE,SAAS,UAAU,EAAE;AAAA,IAC7E,CAAC;AAAA,EACL;AAAA,EAEQ,eAAe,GAAa,MAAgC;AAMhE,WAAO,OAAO,SAAc;AACxB,UAAG,KAAK,iBAAiB,OAAW,OAAM,IAAI,MAAM,+BAA+B;AACnF,UAAG,KAAK,iBAAiB;AACrB,cAAM,IAAI,MAAM,8BAA8B;AAClD,UAAI,UAAU,KAAK,aAAa,WAAW;AAAA,QACvC,QAAQ,EAAE;AAAA,QACV;AAAA,QACA,YAAY,KAAK;AAAA,QACjB,UAAU,KAAK;AAAA,QACf,WAAW;AAAA,QACX,QAAQ;AAAA,MACZ,CAAC;AAED,UAAIA,UAAS,MAAM;AACnB,UAAGA,QAAO,YAAY;AAClB,QAAAA,QAAO,YAAQ,wCAAeA,QAAO,KAAK;AAC9C,aAAOA;AAAA,IACX;AAAA,EACJ;AAAA,EAEA,MAAc,wBAAwB;AAClC,QAAG,KAAK,yBAAyB,OAAW,OAAM,IAAI,MAAM,uCAAuC;AACnG,QAAG,KAAK,YAAY,OAAW,OAAM,IAAI,MAAM,wBAAwB;AAEvE,gBAAI,IAAI,KAAK,IAAI,4DAA4D;AAC7E,gBAAI,IAAI,KAAK,IAAI,yCAAyC,KAAK,qBAAqB,IAAI,IAAI,KAAK,qBAAqB,IAAI,EAAE;AAC5H,QAAG,MAAM,uBAAe,KAAK,oBAAoB,MAAM;AACnD,YAAM,IAAI,MAAM,sCAAsC;AAE1D,SAAK,gBAAgB,IAAI,4BAAoB,KAAK,oBAAoB;AACtE,UAAM,KAAK,cAAc,QAAQ;AAEjC,SAAK,cAAc,SAAS,EAAE,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,KAAK,CAAC;AAEjF,SAAK,gBAAgB,MAAM,KAAK,cAAc,YAAY;AAAA,EAC9D;AAAA,EAEQ,cAAwD;AAE5D,QAAG,KAAK,YAAY,OAAW,OAAM,IAAI,MAAM,wBAAwB;AACvE,QAAI,WAAW,KAAK,QAAQ,YAAY;AACxC,WAAO,SAAS,IAAK,CAAC,MAAkB;AACpC,UAAI,OAAO,EAAE,cAAc;AAC3B,UAAG,SAAS,OAAW,OAAM,IAAI,MAAM,2BAA2B;AAClE,aAAO,IAAI,sBAAc,MAAM,KAAK,SAAoB,KAAK,OAAO;AAAA,IACxE,CAAC,EAAE,OAAO,CAAC,KAAU,MAAqB;AACtC,UAAI,EAAE,IAAI,IAAI;AACd,aAAO;AAAA,IACX,GAAG,CAAC,CAAC;AAAA,EACT;AAAA,EAEO,OAAM;AAET,eAAW,MAAM;AAEb,UAAG,KAAK,gBAAiB,MAAK,gBAAgB,KAAK;AAEnD,UAAG,KAAK,aAAc,MAAK,aAAa,KAAK;AAE7C,UAAG,KAAK,cAAe,MAAK,cAAc,KAAK;AAE/C,UAAG,KAAK,MAAO,MAAK,MAAM,KAAK;AAE/B,UAAG,KAAK,QAAS,MAAK,QAAQ,MAAM;AAEpC,cAAQ,KAAK,CAAC;AAAA,IAClB,GAAG,GAAI;AACP,WAAO;AAAA,EACX;AAOJ;AAIA,IAAO,kBAAQ;;;ACraf,IAAO,kBAAQ;;;ACHf,SAAS,eAAe,KAA+B;AACnD,MAAG,QAAQ,QAAQ,QAAQ,OAAW,QAAO;AAC/C,SACE,OACA,OAAO,QAAQ,YACf,OAAO,OAAO,GAAG,EAAE,KAAK,WAAS,OAAO,UAAU,UAAU;AAEhE;AAWA,SAAS,iBAAiB,OAAkD;AACxE,MAAG,UAAU,QAAQ,UAAU,OAAW,QAAO;AACjD,SAAO,OAAO,UAAU;AAC5B;;;ACVA,IAAM,QAAQ,CAAC,iBAA+B;AAE1C,MAAI,UAAU;AAEd,MAAI,cAAc,wBAAgB,gBAAgB,OAAO,CAAC;AAE1D,MAAI,sBAAsB,IAAI,sBAAoB;AAAA,IAC9C,MAAM,QAAQ;AAAA,IACd,MAAM,QAAQ;AAAA,EAClB,CAAC;AACD,sBAAoB,MAAM;AAE1B,SAAO;AACX;AAGA,IAAM,kBAAkB,CAAC,kBAAgC,CAGrD,QACA,QACA,QACA,WAA4B;AAExB,QAAM,EAAE,gBAAgB,cAAc,QAAQ,IAAI,yBAAyB,QAAQ,QAAQ,MAAM;AACjG,MAAG,mBAAmB,OAAW,OAAM,IAAI,MAAM,8BAA8B;AAE/E,QAAM,eAAe;AAErB,QAAM,OAAO,cAAc;AAC3B,QAAM,OAAO,cAAc;AAE3B,MAAI,UAAU,IAAI,gBAAQ;AAAA,IACtB;AAAA,IACA,sBAAsB,EAAE,MAAM,KAAK;AAAA,IACnC;AAAA,IACA;AAAA,IACA;AAAA,EACJ,CAAC;AACD,UAAQ,MAAM;AAClB;AAGJ,IAAM,2BAA2B,CAAC,QAAuC,QAAwC,WAA4B;AACzI,MAAI,gBAAgB,cAAc;AAElC,MAAI,iBAAiB,MAAM,GAAI;AAC3B,qBAAiB;AAEjB,QAAI,eAAe,MAAM,GAAI;AACzB,qBAAe;AACf,gBAAU,UAAU,CAAC;AAAA,IACzB;AAAA,EACJ,WAAW,eAAe,MAAM,GAAI;AAChC,qBAAiB,MAAM;AAAA,IAAC;AACxB,mBAAe;AAEf,cAAU,UAAU,CAAC;AAAA,EACzB,OAAO;AACH,UAAM,IAAI,MAAM,kEAAkE;AAAA,EACtF;AACA,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AACJ;AAKA,IAAO,gBAAS;;;ACtFhB,cAAyB;;;ACQzB,IAAO,cAAQ;;;AhCHf,IAAO,gBAAQ;","names":["result","uuidv4","result","connection","result","import_socket","result","process","code","service","result","node","result","os","import_serialize_error","code","fn","import_serialize_error","getPort","result"]}