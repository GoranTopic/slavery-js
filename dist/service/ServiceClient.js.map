{"version":3,"sources":["../../src/service/ServiceClient.ts"],"sourcesContent":["import Network, { Listener } from '../network/index.js';\nimport { deserializeError } from 'serialize-error';\n\ntype Options = {\n    throwError?: boolean,\n    returnError?: boolean,\n    logError?: boolean\n}\n\n\nclass ServiceClient {\n    /* this class will be used to connect to a diffrent service,\n     * it will convert the class into a client handler for other services\n     * it will connect to the service and create methods\n     * for every listener that the service has. */\n    public name: string;\n    public network: Network;\n    public options: Options;\n    // this is use to select nodes\n    public selection: string[] = []; \n    private listeners: Listener[] = [];\n    // get the network from the connection\n    constructor(name: string, network: Network, options: Options = {}, selection?: [] ) {\n        this.name = name;\n        this.network = network;\n        if(options.throwError === undefined) options.throwError = true;\n        this.options = options;\n        this.selection = selection || [];\n        // get the conenction from the network\n        let connection = this.network.getService(name);\n        if(connection === null) throw new Error(`Service ${name} not found`);\n        // get the listneres from the target connection\n        this.listeners = connection.targetListeners;\n        // if we have a selection\n        if(this.selection.length === 0) {\n            // create method from listners which run the query on the connection\n            this.listeners.forEach((listener: Listener) => {\n                (this as any)[listener.event] = \n                    async (parameters: any) => await this.sendRequest(listener.event, { parameters });\n            });\n        }else{\n            // create method from listners which run the query on the connection\n            this.listeners.forEach((listener: Listener) => {\n                (this as any)[listener.event] = \n                    // if we have a selection we send a request to every node on the selection\n                    async (parameters: any) => {\n                    let results = await Promise.all(\n                        this.selection.map(\n                            async (nodeId: string) => await this.sendRequest(\n                                listener.event, { parameters, selection: nodeId }\n                            )\n                        )\n                    )\n                    // if we only have one node we return the result\n                    if(results.length === 1) return results[0];\n                    else return results;\n                }\n            });\n        }\n    }\n\n    private async sendRequest(event: string, data: any) {\n        // get the connection\n        let connection = this.network.getService(this.name);\n        // and send the data\n        if (connection === null) throw new Error(`Service ${this.name} not found`);\n        let response = await connection.send(event, data);\n        // check if we got an error and handle it\n        if (response.isError === true) \n            return this.handleErrors(response.error);\n        return response.result;\n    }\n\n\n    // We define a seperate method selecting \n    // a one or a group of nodes in a service\n    public async select(num?: number | 'all') {\n        // undefined selects all nodes\n        if(num === undefined) num = 1\n        if(num === 'all') num = 0\n        // send server to select a node\n        let selection = await this.sendRequest('_select', { parameters: num });\n        // check if we got an error and handle it\n        if(selection === null) return;\n        // set the selection\n        return new ServiceClient(this.name, this.network, this.options, selection);\n    }\n\n    public async exec(code: string) {\n        // execute albitrary code on the a node\n        if(this.selection.length === 0) {\n            return await this.sendRequest('_exec', { parameters: code.toString() });\n        } else {\n            // if we have selection we send a request to every node on the selection\n           let results = await Promise.all(\n                this.selection.map(\n                    async (nodeId: string) => await this.sendRequest(\n                        '_exec', { parameters: code.toString(), selection: nodeId }\n                    )\n                )\n            );\n            // if we only have one node we return the result\n            if(results.length === 1) return results[0];\n            else return results;\n        }\n    }\n\n\n    public async exec_master(code: string) {\n        // execute albitrary code on the master node\n        return await this.sendRequest('_exec_master', { parameters: code.toString() });\n    }\n\n    private handleErrors(error_obj: Error) {\n        // deserialize the error, handle according to the options\n        let error = deserializeError(error_obj);\n        if (this.options.throwError) throw error;\n        if (this.options.logError) console.error(error);\n        if (this.options.returnError) return error;\n        else return null;\n    }\n    \n}\n\nexport default ServiceClient;\n"],"mappings":"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","names":[]}