{"version":3,"sources":["../../src/app/entry.ts"],"sourcesContent":["import PeerDiscoveryServer from './peerDiscovery/index.js';\nimport makeProxyObject from './makeProxyObject.js';\nimport Service, { SlaveMethods, Options as ServiceOptions } from '../service/index.js';\nimport { isSlaveMethods, isMasterCallback } from './typeGuards.js';\n\ntype CallableFunction = (...args: any[]) => any;\n\ntype MasterCallback = Function | CallableFunction;\n\ntype EntryOptions = {\n    host: string;\n    port: number;\n}\n\nconst entry = (entryOptions: EntryOptions) => {\n    // this function is use to set up the options for the servies\n    let options = entryOptions;\n    // make a proxy object will take of creating each service\n    let proxyObject = makeProxyObject(handleProxyCall(options));\n    // make the peer discovery server\n    let peerDiscoveryServer = new PeerDiscoveryServer({\n        host: options.host,\n        port: options.port,\n    });\n    peerDiscoveryServer.start();\n    // return the proxy object\n    return proxyObject; // <--- the proxy obj will return itself in perpituity\n}\n\n\nconst handleProxyCall = (globalOptions: EntryOptions) => (\n    // this are all of the possible input to service now the question is who to know \n    // which one wa passed\n    method: string,\n    param1: MasterCallback | SlaveMethods,\n    param2?: SlaveMethods | ServiceOptions, \n    param3?: ServiceOptions) => {\n        // first we check which function where passed\n        const { mastercallback, slaveMethods, options } = paramertesDiscermination(param1, param2, param3);\n        if(mastercallback === undefined) throw new Error('Master callback is undefined');\n        // get the service name and the functions\n        const service_name = method;\n        // get the port and the host\n        const port = globalOptions.port;\n        const host = globalOptions.host;\n        // make a new service\n        let service = new Service({\n            service_name,\n            peerDiscoveryAddress: { host, port },\n            mastercallback: mastercallback as CallableFunction,\n            slaveMethods,\n            options,\n        })\n        service.start()\n    }\n\n// this function will take the parameters and determine what they are\n// and return them in a format that is easy to work with\nconst paramertesDiscermination = (param1: MasterCallback | SlaveMethods, param2?: SlaveMethods | ServiceOptions, param3?: ServiceOptions) => {\n    let mastercallback: MasterCallback;\n    let slaveMethods: SlaveMethods;\n    let options: ServiceOptions;\n    // check if the first paramet is either a MasterCallback or SlaveMethods\n    if( isMasterCallback(param1) ) {\n        mastercallback = param1;\n        // check what the second paramter is\n        if( isSlaveMethods(param2) ) {\n            slaveMethods = param2;\n            options = param3 || {};\n        } else if( typeof param2 === 'object' ) {\n            options = param2;\n            slaveMethods = {};\n        } else if(param2 === undefined ) {\n            options = {};\n            slaveMethods = {};\n        }else{\n            throw new Error(`Invalid second parameter of type of ${typeof param2}. Must be either an object of function, options or undefined`);\n        }\n    } else if( isSlaveMethods(param1) ) {\n        mastercallback = () => {};\n        slaveMethods = param1;\n        // check what the second paramter is\n        options = param2 || {};\n    } else { \n        throw new Error(`Invalid first parameter of type of ${typeof param1}. Must be either an function or an object of functions`);\n    }\n    return { \n        mastercallback,\n        slaveMethods,\n        options\n    }\n}\n\n\n\nexport default  entry;\n"],"mappings":";AAAA,OAAO,yBAAyB;AAChC,OAAO,qBAAqB;AAC5B,OAAO,aAA0D;AACjE,SAAS,gBAAgB,wBAAwB;AAWjD,MAAM,QAAQ,CAAC,iBAA+B;AAE1C,MAAI,UAAU;AAEd,MAAI,cAAc,gBAAgB,gBAAgB,OAAO,CAAC;AAE1D,MAAI,sBAAsB,IAAI,oBAAoB;AAAA,IAC9C,MAAM,QAAQ;AAAA,IACd,MAAM,QAAQ;AAAA,EAClB,CAAC;AACD,sBAAoB,MAAM;AAE1B,SAAO;AACX;AAGA,MAAM,kBAAkB,CAAC,kBAAgC,CAGrD,QACA,QACA,QACA,WAA4B;AAExB,QAAM,EAAE,gBAAgB,cAAc,QAAQ,IAAI,yBAAyB,QAAQ,QAAQ,MAAM;AACjG,MAAG,mBAAmB,OAAW,OAAM,IAAI,MAAM,8BAA8B;AAE/E,QAAM,eAAe;AAErB,QAAM,OAAO,cAAc;AAC3B,QAAM,OAAO,cAAc;AAE3B,MAAI,UAAU,IAAI,QAAQ;AAAA,IACtB;AAAA,IACA,sBAAsB,EAAE,MAAM,KAAK;AAAA,IACnC;AAAA,IACA;AAAA,IACA;AAAA,EACJ,CAAC;AACD,UAAQ,MAAM;AAClB;AAIJ,MAAM,2BAA2B,CAAC,QAAuC,QAAwC,WAA4B;AACzI,MAAI;AACJ,MAAI;AACJ,MAAI;AAEJ,MAAI,iBAAiB,MAAM,GAAI;AAC3B,qBAAiB;AAEjB,QAAI,eAAe,MAAM,GAAI;AACzB,qBAAe;AACf,gBAAU,UAAU,CAAC;AAAA,IACzB,WAAW,OAAO,WAAW,UAAW;AACpC,gBAAU;AACV,qBAAe,CAAC;AAAA,IACpB,WAAU,WAAW,QAAY;AAC7B,gBAAU,CAAC;AACX,qBAAe,CAAC;AAAA,IACpB,OAAK;AACD,YAAM,IAAI,MAAM,uCAAuC,OAAO,MAAM,8DAA8D;AAAA,IACtI;AAAA,EACJ,WAAW,eAAe,MAAM,GAAI;AAChC,qBAAiB,MAAM;AAAA,IAAC;AACxB,mBAAe;AAEf,cAAU,UAAU,CAAC;AAAA,EACzB,OAAO;AACH,UAAM,IAAI,MAAM,sCAAsC,OAAO,MAAM,wDAAwD;AAAA,EAC/H;AACA,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AACJ;AAIA,IAAO,gBAAS;","names":[]}