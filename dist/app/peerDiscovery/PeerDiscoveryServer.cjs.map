{"version":3,"sources":["../../../src/app/peerDiscovery/PeerDiscoveryServer.ts"],"sourcesContent":["import Network, { Listener } from '../../network/index.js';\nimport Cluster from '../../cluster/index.js';\nimport type { ServiceAddress } from '../../service/index.js';\n//import { log } from '../../utils/index.js';\n\ntype Parameters = {\n    host: string,\n    port: number,\n};\n\nclass PeerDicoveryServer {\n    /* This will be the based class for the service which salvery will call to create proceses */\n    public name: string; \n    public host: string;\n    public port: number;\n    private cluster: Cluster | null = null;\n    private network: Network | null = null;\n    private services: { [key: string]: ServiceAddress } = {};\n\n    constructor(params: Parameters) {\n        this.name = 'peer_discovery';\n        // the address of the service will take\n        this.host = params.host;\n        this.port = params.port;\n    }\n\n    public async start() { \n        // let initlize the cluster\n        this.cluster = new Cluster({ name: this.name });\n        this.cluster.spawn(this.name, {\n            spawnOnlyFromPrimary: true // make sure that only one the primary process can spawn this service\n        });\n        // run the peer discovery service\n        if(this.cluster.is('peer_discovery')){\n            //log(`starting peer discovery service...`);\n            // now we will create the network\n            this.network = new Network({name: this.name + '_network'});\n            // get the listneres\n            let listeners = this.getListeners();\n            // create the server\n            this.network.createServer(this.name, this.host, this.port, listeners);\n        }\n        return;\n    }\n\n    private getListeners(): Listener[] {\n        // this will be the listeners for the peer discovery service\n        // this is the eonly traffic that the server will have.\n        let listeners = [{\n            // get number of nodes\n            event: 'register_service',\n            params: ['name', 'host', 'port'],\n            callback: this.registerService.bind(this)\n        },{\n            event: 'get_services',\n            callback: this.getServices.bind(this)\n        },{\n            event: 'remove_service',\n            params: ['name'],\n            callback: this.removeService.bind(this)\n        },{ // select individual nodes, or groups of nodes\n            event: 'exit',\n            callback: this.exit.bind(this)\n        }];\n        return listeners;\n    }\n\n    private registerService({ name, host, port }: ServiceAddress) {\n        if(this.network === null) throw new Error('Network is not initialized');\n        // check if the service is already registered\n        if(this.services[name]) throw new Error(`Service ${name} is already registered`);\n        // add the service to the list of services\n        this.services[name] = { name, host, port };\n        // broadcast the new service to all the nodes\n        if(this.network === null) throw new Error('Network is not initialized');\n        if(this.network.server === null) throw new Error('Server is not initialized');\n        this.network.server.broadcast('new_service', { name, host, port });\n        return;\n    }\n\n    private getServices() : ServiceAddress[] {\n        return Object.values(this.services);\n    }\n\n    private removeService(name: string) {\n        if(!this.services[name]) return false;\n        if(this.network === null) throw new Error('Network is not initialized');\n        if(this.network.server === null) throw new Error('Server is not initialized');\n        // remove the service from the list of services\n        delete this.services[name];\n        // broadcast the removal of the service\n        this.network.server.broadcast('remove_service', { name });\n        return true;\n    }\n\n\n    public exit(){\n        //log(`[${this.name}] will exit in 1 seconds`);\n        setTimeout(() => {\n            if(this.network) this.network.close();\n            // lastly we close ourselves, how sad\n            process.exit(0);\n        }, 1000);\n        return true\n    }\n\n}\n\n\n\nexport default PeerDicoveryServer;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBAAkC;AAClC,qBAAoB;AASpB,MAAM,mBAAmB;AAAA,EASrB,YAAY,QAAoB;AAPhC;AAAA,wBAAO;AACP,wBAAO;AACP,wBAAO;AACP,wBAAQ,WAA0B;AAClC,wBAAQ,WAA0B;AAClC,wBAAQ,YAA8C,CAAC;AAGnD,SAAK,OAAO;AAEZ,SAAK,OAAO,OAAO;AACnB,SAAK,OAAO,OAAO;AAAA,EACvB;AAAA,EAEA,MAAa,QAAQ;AAEjB,SAAK,UAAU,IAAI,eAAAA,QAAQ,EAAE,MAAM,KAAK,KAAK,CAAC;AAC9C,SAAK,QAAQ,MAAM,KAAK,MAAM;AAAA,MAC1B,sBAAsB;AAAA;AAAA,IAC1B,CAAC;AAED,QAAG,KAAK,QAAQ,GAAG,gBAAgB,GAAE;AAGjC,WAAK,UAAU,IAAI,eAAAC,QAAQ,EAAC,MAAM,KAAK,OAAO,WAAU,CAAC;AAEzD,UAAI,YAAY,KAAK,aAAa;AAElC,WAAK,QAAQ,aAAa,KAAK,MAAM,KAAK,MAAM,KAAK,MAAM,SAAS;AAAA,IACxE;AACA;AAAA,EACJ;AAAA,EAEQ,eAA2B;AAG/B,QAAI,YAAY,CAAC;AAAA;AAAA,MAEb,OAAO;AAAA,MACP,QAAQ,CAAC,QAAQ,QAAQ,MAAM;AAAA,MAC/B,UAAU,KAAK,gBAAgB,KAAK,IAAI;AAAA,IAC5C,GAAE;AAAA,MACE,OAAO;AAAA,MACP,UAAU,KAAK,YAAY,KAAK,IAAI;AAAA,IACxC,GAAE;AAAA,MACE,OAAO;AAAA,MACP,QAAQ,CAAC,MAAM;AAAA,MACf,UAAU,KAAK,cAAc,KAAK,IAAI;AAAA,IAC1C,GAAE;AAAA;AAAA,MACE,OAAO;AAAA,MACP,UAAU,KAAK,KAAK,KAAK,IAAI;AAAA,IACjC,CAAC;AACD,WAAO;AAAA,EACX;AAAA,EAEQ,gBAAgB,EAAE,MAAM,MAAM,KAAK,GAAmB;AAC1D,QAAG,KAAK,YAAY,KAAM,OAAM,IAAI,MAAM,4BAA4B;AAEtE,QAAG,KAAK,SAAS,IAAI,EAAG,OAAM,IAAI,MAAM,WAAW,IAAI,wBAAwB;AAE/E,SAAK,SAAS,IAAI,IAAI,EAAE,MAAM,MAAM,KAAK;AAEzC,QAAG,KAAK,YAAY,KAAM,OAAM,IAAI,MAAM,4BAA4B;AACtE,QAAG,KAAK,QAAQ,WAAW,KAAM,OAAM,IAAI,MAAM,2BAA2B;AAC5E,SAAK,QAAQ,OAAO,UAAU,eAAe,EAAE,MAAM,MAAM,KAAK,CAAC;AACjE;AAAA,EACJ;AAAA,EAEQ,cAAiC;AACrC,WAAO,OAAO,OAAO,KAAK,QAAQ;AAAA,EACtC;AAAA,EAEQ,cAAc,MAAc;AAChC,QAAG,CAAC,KAAK,SAAS,IAAI,EAAG,QAAO;AAChC,QAAG,KAAK,YAAY,KAAM,OAAM,IAAI,MAAM,4BAA4B;AACtE,QAAG,KAAK,QAAQ,WAAW,KAAM,OAAM,IAAI,MAAM,2BAA2B;AAE5E,WAAO,KAAK,SAAS,IAAI;AAEzB,SAAK,QAAQ,OAAO,UAAU,kBAAkB,EAAE,KAAK,CAAC;AACxD,WAAO;AAAA,EACX;AAAA,EAGO,OAAM;AAET,eAAW,MAAM;AACb,UAAG,KAAK,QAAS,MAAK,QAAQ,MAAM;AAEpC,cAAQ,KAAK,CAAC;AAAA,IAClB,GAAG,GAAI;AACP,WAAO;AAAA,EACX;AAEJ;AAIA,IAAO,8BAAQ;","names":["Cluster","Network"]}